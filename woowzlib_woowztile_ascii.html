<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ASCII Generator - Pixel Render</title>
<style>
body {
  margin:0; padding:0; font-family: 'Courier New', monospace;
  background: #111; color: #eee;
}
.wrapper { display:flex; gap:20px; padding:20px; align-items:flex-start; }
.left, .right {
  display:flex; flex-direction:column; gap:12px;
  background:#1a1a1a; padding:20px; border-radius:10px;
  box-shadow:0 0 20px rgba(255,0,0,0.2);
}
.left { flex:1; }
textarea { width:100%; min-height:120px; padding:10px; background:#222; border:1px solid #555; border-radius:6px; color:#0f0; font-family:monospace; font-size:14px; resize:vertical; }
textarea:focus { border:1px solid #f00; outline:none; }
input[type="number"], input[type="file"] { padding:6px 10px; border-radius:6px; border:1px solid #555; background:#222; color:#eee; }
button { padding:8px 14px; background:#f00; color:#fff; border:none; border-radius:6px; cursor:pointer; font-family:monospace; font-size:14px; transition:.2s; }
button:hover { background:#ff4d4d; box-shadow:0 0 10px rgba(255,0,0,0.5); }
#output, #asciiCanvas { font-size:1.3em; background:#222; padding:10px; border-radius:6px; overflow:auto; white-space:pre; min-height:150px; border:1px solid #555; image-rendering: pixelated; }
.right { width:320px; }
label { font-weight:bold; margin-bottom:4px; display:block; font-size:14px; }
</style>
</head>
<body>

<div class="wrapper">
  <div class="left">
    <label>Mapping (C# format):</label>
    <textarea id="mappingInput"></textarea>

    <label>Palette (C# KeyValuePair format):</label>
    <textarea id="paletteInput"></textarea>

    <label>Scale:</label>
    <input type="number" id="scaleInput" value="1" step="0.05">

    <input type="file" id="imageInput" accept="image/*">
    <button id="pasteImageButton">Load Image from Clipboard</button>
    <button id="generateButton">Generate ASCII</button>
    <button id="copyButton">Copy ASCII</button>

    <label>ASCII Output:</label>
    <pre id="output"></pre>

    <label>ASCII Input:</label>
    <textarea id="asciiInput"></textarea>
    <button id="generateImageButton">Generate Image from ASCII</button>
    <button id="copyImageButton">Copy Image</button>

    <canvas id="canvas" style="display:none;"></canvas>
    <canvas id="asciiCanvas"></canvas>
  </div>

  <div class="right">
    <label>Mapping (Right Panel):</label>
    <textarea id="mappingInputRight"></textarea>

    <label>Palette (Right Panel):</label>
    <textarea id="paletteInputRight"></textarea>

    <button id="swapButton">Swap Left & Right</button>
  </div>
</div>

<script>
let LoadedImage = null;
const NamedColors = {
  LightRed:[255,63,63,255], Red:[255,0,0,255], DarkRed:[128,0,0,255],
  LightOrange:[255,191,63,255], Orange:[255,128,0,255], DarkOrange:[128,63,0,255],
  Brown:[128,63,0,255], LightYellow:[255,255,63,255], Yellow:[255,255,0,255],
  DarkYellow:[128,128,0,255], LightGreen:[63,255,63,255], Green:[0,255,0,255],
  DarkGreen:[0,128,0,255], LightAqua:[63,255,255,255], Aqua:[0,255,255,255],
  DarkAqua:[0,128,128,255], LightBlue:[63,63,255,255], Blue:[0,0,255,255],
  DarkBlue:[0,0,128,255], LightPurple:[191,63,255,255], Purple:[128,0,255,255],
  DarkPurple:[63,0,128,255], LightMagenta:[255,63,255,255], Magenta:[255,0,255,255],
  DarkMagenta:[128,0,128,255], LightPink:[255,191,255,255], Pink:[255,128,255,255],
  DarkPink:[128,63,128,255], White:[255,255,255,255], LightGray:[191,191,191,255],
  Gray:[128,128,128,255], DarkGray:[63,63,63,255], Black:[0,0,0,255],
  Transparent:[255,255,255,0], One:[255,255,255,255], Half:[128,128,128,128], Zero:[0,0,0,0]
};

// --- Swap ---
document.getElementById("swapButton").addEventListener("click", ()=>{
  const leftMap = document.getElementById("mappingInput");
  const leftPal = document.getElementById("paletteInput");
  const rightMap = document.getElementById("mappingInputRight");
  const rightPal = document.getElementById("paletteInputRight");
  [leftMap.value,rightMap.value]=[rightMap.value,leftMap.value];
  [leftPal.value,rightPal.value]=[rightPal.value,leftPal.value];
});

// --- Load Image ---
document.getElementById("pasteImageButton").addEventListener("click",async ()=>{
  try{
    const items=await navigator.clipboard.read();
    for(const item of items){
      for(const type of item.types){
        if(type.startsWith("image/")){
          const blob=await item.getType(type);
          const img=new Image();
          img.onload=()=>{LoadedImage=img; autoGenerateIfReady();};
          img.src=URL.createObjectURL(blob);
          return;
        }
      }
    }
    alert("No image found in clipboard");
  }catch(e){alert("Failed: "+e);}
});
document.getElementById("imageInput").addEventListener("change",e=>{
  const file=e.target.files[0]; if(!file) return;
  const img=new Image();
  img.onload=()=>{LoadedImage=img; autoGenerateIfReady();};
  img.src=URL.createObjectURL(file);
});

function autoGenerateIfReady(){
  if(!LoadedImage) return;
  const mapping=parseMapping();
  const palette=parsePalette();
  if(mapping && palette) generateAscii();
}

// --- Mapping & Palette ---
function parseMapping(){
  const text=document.getElementById("mappingInput").value;
  const regex=/\['(.?)'\]\s*=\s*(\d+)/g;
  const mapping={}; let match;
  while((match=regex.exec(text))!==null) mapping[match[1]]=parseInt(match[2]);
  return Object.keys(mapping).length?mapping:null;
}

function parsePalette() {
    const text = document.getElementById("paletteInput").value;

    // Regex поддерживает два варианта:
    // 1) KeyValuePair<byte, ColorB>(1, ColorB.Red.SetA(128))
    // 2) KeyValuePair<byte, ColorB>(10, new ColorB(198,151,151))
    const regex = /KeyValuePair<byte,\s*ColorB>\((\d+)\s*,\s*(?:ColorB\.([A-Za-z]+)(?:\.SetA\((\d+)\))?|new ColorB\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+))?\))\)/g;

    const palette = {};
    let match;
    while ((match = regex.exec(text)) !== null) {
        const byte = parseInt(match[1]);
        if (byte === 0) { palette[0] = [0, 0, 0, 0]; continue; }

        if (match[2]) {
            // Named color
            const colorName = match[2];
            const setAlpha = match[3] !== undefined ? parseInt(match[3]) : undefined;
            if (NamedColors[colorName]) {
                const [r, g, b, dA] = NamedColors[colorName];
                const a = setAlpha !== undefined ? setAlpha : dA ?? 255;
                palette[byte] = [r, g, b, a];
            }
        } else {
            // new ColorB(r,g,b[,a])
            const r = parseInt(match[4]);
            const g = parseInt(match[5]);
            const b = parseInt(match[6]);
            const a = match[7] !== undefined ? parseInt(match[7]) : 255;
            palette[byte] = [r, g, b, a];
        }
    }

    console.log(palette);
    return palette;
}

// --- ASCII Generation ---
document.getElementById("generateButton").addEventListener("click",()=>{
  if(!LoadedImage){alert("Load image first"); return;}
  generateAscii();
});
document.getElementById("copyButton").addEventListener("click",()=>{
  navigator.clipboard.writeText(document.getElementById("output").textContent);
});

function generateAscii(){
  const mapping=parseMapping(); const palette=parsePalette();
  if(!mapping||!palette) return;
  const rev=Object.fromEntries(Object.entries(mapping).map(([k,v])=>[v.toString(),k]));
  const canvas=document.getElementById("canvas"); const ctx=canvas.getContext("2d");
  const scale=parseFloat(document.getElementById("scaleInput").value)||0.2;
  canvas.width=LoadedImage.width*scale; canvas.height=LoadedImage.height*scale;
  ctx.drawImage(LoadedImage,0,0,canvas.width,canvas.height);
  const data=ctx.getImageData(0,0,canvas.width,canvas.height).data;
  const lines=[];
  for(let y=0;y<canvas.height;y++){
    let line='';
    for(let x=0;x<canvas.width;x++){
      const i=(y*canvas.width+x)*4;
      const [r,g,b,a]=[data[i],data[i+1],data[i+2],data[i+3]];
      let c='.';
      if(a>=10){const closest=getClosestPalette(r,g,b,a,palette); c=rev[closest.toString()]??'.';}
      else c=rev['0']??'.';
      line+=c;
    }
    lines.push(line);
  }
  document.getElementById("output").textContent=lines.join("\n");
}

// --- ASCII → Pixel Image ---
document.getElementById("generateImageButton").addEventListener("click",()=>{
  const ascii=document.getElementById("asciiInput").value;
  const mapping=parseMapping();
  const palette=parsePalette();
  if(!ascii||!mapping||!palette){alert("ASCII, mapping or palette missing"); return;}
  generateImageFromAscii(ascii,mapping,palette);
});
document.getElementById("copyImageButton").addEventListener("click",()=>{
  const canvas=document.getElementById("asciiCanvas");
  canvas.toBlob(blob=>{
    navigator.clipboard.write([new ClipboardItem({'image/png':blob})]);
  });
});

function generateImageFromAscii(ascii,mapping,palette){
  const lines=ascii.split("\n");
  const width=lines[0]?.length||0; const height=lines.length;
  const canvas=document.getElementById("asciiCanvas"); const ctx=canvas.getContext("2d");
  canvas.width=width; canvas.height=height;
  const imgData=ctx.createImageData(width,height);
  const byteMapping=Object.fromEntries(Object.entries(mapping).map(([k,v])=>[k,v]));
  for(let y=0;y<height;y++){
    for(let x=0;x<width;x++){
      const ch=lines[y][x];
      const idx=(y*width+x)*4;
      if(ch=='.'){ imgData.data[idx+3]=0; continue; }
      const b=byteMapping[ch]; const col=palette[b]||[0,0,0,255];
      imgData.data[idx]=col[0]; imgData.data[idx+1]=col[1]; imgData.data[idx+2]=col[2]; imgData.data[idx+3]=col[3];
    }
  }
  ctx.putImageData(imgData,0,0);
  // масштаб для видимости
  const scale=parseFloat(document.getElementById("scaleInput").value)||1;
  if(scale!==1){
    const temp=document.createElement("canvas");
    temp.width=canvas.width*scale; temp.height=canvas.height*scale;
    temp.getContext("2d").imageSmoothingEnabled=false;
    temp.getContext("2d").drawImage(canvas,0,0,temp.width,temp.height);
    canvas.width=temp.width; canvas.height=temp.height;
    ctx.drawImage(temp,0,0);
  }
}

function getClosestPalette(r,g,b,a,palette){
  if(a<10) return 0;
  let minDist=Infinity,best=0;
  for(const k in palette){
    const c=palette[k]; if(!c) continue;
    const [pr,pg,pb,pa]=c;
    const dist=0.299*(r-pr)*(r-pr)+0.587*(g-pg)*(g-pg)+0.114*(b-pb)*(b-pb)+0.5*(a-pa)*(a-pa);
    if(dist<minDist){ minDist=dist; best=k; }
  }
  return best;
}
</script>

</body>
</html>
