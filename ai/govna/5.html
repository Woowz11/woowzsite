<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Литуизм: Мелодия и Визуализация из Текста с Настройкой</title>
  <style>
    body {
      margin: 0; 
      background: #110011;
      color: #ff0044;
      font-family: "Consolas", monospace;
      overflow: hidden;
      user-select: none;
      display: flex; 
      flex-direction: column;
      align-items: center;
      height: 100vh;
    }
    h1 {
      margin: 1rem;
      text-shadow: 0 0 15px #ff0044;
    }
    textarea {
      width: 80vw;
      height: 80px;
      background: #330033;
      border: 2px solid #ff0044;
      color: #ff4499;
      font-size: 18px;
      padding: 10px;
      resize: none;
      outline: none;
      margin-bottom: 10px;
      box-shadow: 0 0 15px #ff0044 inset;
    }
    button {
      background: #660066;
      color: #ff4499;
      border: 1px solid #ff0044;
      font-size: 18px;
      padding: 10px 20px;
      cursor: pointer;
      box-shadow: 0 0 25px #ff0044;
      transition: 0.3s;
      margin-bottom: 10px;
    }
    button:hover {
      background: #aa00aa;
      box-shadow: 0 0 40px #ff0044;
    }
    input[type=range] {
      width: 80vw;
      margin-bottom: 15px;
      -webkit-appearance: none;
      height: 8px;
      border-radius: 4px;
      background: #550055;
      box-shadow: 0 0 15px #ff0044 inset;
      cursor: pointer;
    }
    canvas {
      display: block;
      background: #220022;
      box-shadow: 0 0 50px #ff0044;
      border: 3px solid #ff0044;
      flex-grow: 1;
      width: 100vw;
      height: calc(100vh - 280px);
    }
    #curse {
      font-size: 14px;
      color: #aa0044;
      font-style: italic;
      text-shadow: 0 0 5px #550022;
      user-select: none;
      margin-top: 5px;
      pointer-events: none;
      height: 18px;
    }
  </style>
</head>
<body>

  <h1>ЛИТУИЗМ: МЕЛОДИЯ + ВИЗУАЛИЗАЦИЯ ИЗ ТЕКСТА</h1>
  <textarea id="inputText" placeholder="Пиши, ссаный питух..."></textarea>
  <label for="speedRange">Скорость музыки (темп): <span id="speedDisplay">1.0</span>x</label>
  <input type="range" id="speedRange" min="0.2" max="3" step="0.05" value="1" />
  <button id="startBtn">Начать ритуал</button>
  <div id="curse">Проклятие питухам загружено и готово!</div>
  <canvas id="glitchCanvas"></canvas>

  <script>
    // === Seeded random generator (Mulberry32) ===
    function mulberry32(a) {
      return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }

    // === Хэш из строки в число для сида ===
    function cyrb128(str) {
      let h1 = 1779033703, h2 = 3144134277,
          h3 = 1013904242, h4 = 2773480762;
      for(let i=0, k; i<str.length; i++){
        k = str.charCodeAt(i);
        h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
        h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
        h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
        h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
      }
      h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
      h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
      h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
      h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
      return (h1 ^ h2 ^ h3 ^ h4) >>> 0;
    }

    // === Пиксельный сетап ===
    const canvas = document.getElementById('glitchCanvas');
    const ctx = canvas.getContext('2d');
    const pixelSize = 8;
    let gridCols, gridRows;
    let pixels = [];

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - 280;
      gridCols = Math.floor(canvas.width / pixelSize);
      gridRows = Math.floor(canvas.height / pixelSize);
      pixels = new Array(gridCols * gridRows).fill(0).map(() => ({
        baseColor: [0,0,0],
        x: 0, y: 0,
        offsetX: 0,
        offsetY: 0,
        alpha: 0
      }));
      initPixels();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // === Цвета для пикселей — расширяем палитру литуизма ===
    // В формате [R,G,B], баговые цвета, кислотные
    const baseColorsPalette = [
      [180, 20, 20],   // кроваво-красный
      [40, 180, 40],   // ядовито-зеленый
      [30, 40, 180],   // кислый синий
      [180, 20, 180],  // баговый пурпурный
      [220, 160, 20],  // выцветший желтый
      [100, 100, 100], // тёмно-серый баг
    ];

    function initPixels() {
      for(let y = 0; y < gridRows; y++) {
        for(let x = 0; x < gridCols; x++) {
          const idx = y * gridCols + x;
          pixels[idx].x = x * pixelSize;
          pixels[idx].y = y * pixelSize;
          // случайный базовый цвет из палитры
          pixels[idx].baseColor = baseColorsPalette[Math.floor(Math.random()*baseColorsPalette.length)];
          pixels[idx].offsetX = Math.random() * 2 - 1;
          pixels[idx].offsetY = Math.random() * 2 - 1;
          pixels[idx].alpha = 0.4 + Math.random() * 0.6;
        }
      }
    }

    // === Аудио ===
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playTone(freq, duration, time, volume = 0.2) {
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(freq, time);
      gainNode.gain.setValueAtTime(volume, time);
      gainNode.gain.exponentialRampToValueAtTime(0.001, time + duration);
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      osc.start(time);
      osc.stop(time + duration);
    }

    function playNoise(duration, time, volume = 0.1) {
      const bufferSize = audioCtx.sampleRate * duration;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0; i<bufferSize; i++) data[i] = (Math.random()*2-1)*0.2;
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const gainNode = audioCtx.createGain();
      gainNode.gain.setValueAtTime(volume, time);
      gainNode.gain.exponentialRampToValueAtTime(0.001, time + duration);
      noise.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      noise.start(time);
      noise.stop(time + duration);
    }

    // === Конвертация текста в мелодию с арпеджио ===
    function charFreq(charCode, octaveShift = 0) {
      const base = 150 + ((charCode - 32) / (126 - 32)) * 750;
      return base * Math.pow(2, octaveShift / 12);
    }

    // === Эффекты, применяемые по буквам ===
    // Определяем фиксированные эффекты по букве (a-f), остальные рандомно с seed
    function letterEffect(char, seedRandom) {
      switch(char) {
        case 'a': return 'shiftRight';
        case 'b': return 'invertColors';
        case 'c': return 'boostRedOddPixels';
        case 'd': return 'shiftDown';
        case 'e': return 'boostBlueEvenPixels';
        case 'f': return 'glitchShift';
        default:
          // Рандом выбор эффекта
          const effects = ['shiftRight', 'invertColors', 'boostRedOddPixels', 'shiftDown', 'boostBlueEvenPixels', 'glitchShift', 'boostGreen'];
          return effects[Math.floor(seedRandom()*effects.length)];
      }
    }

    // === Применение эффектов к пикселям с эффектами от буквы ===
    function applyEffectToPixels(effectName, time) {
      switch(effectName) {
        case 'shiftRight':
          for(let i=0; i<pixels.length; i++) {
            pixels[i].offsetX = 1 + 0.5 * Math.sin(time * 4 + i);
          }
          break;
        case 'shiftDown':
          for(let i=0; i<pixels.length; i++) {
            pixels[i].offsetY = 1 + 0.5 * Math.cos(time * 3 + i);
          }
          break;
        case 'invertColors':
          for(let i=0; i<pixels.length; i++) {
            let c = pixels[i].baseColor;
            pixels[i].baseColor = [255-c[0], 255-c[1], 255-c[2]];
          }
          break;
        case 'boostRedOddPixels':
          for(let i=0; i<pixels.length; i++) {
            if(i % 6 < 3) {
              let c = pixels[i].baseColor;
              pixels[i].baseColor = [Math.min(255, c[0]+100), c[1], c[2]];
            }
          }
          break;
        case 'boostBlueEvenPixels':
          for(let i=0; i<pixels.length; i++) {
            if(i % 2 === 0) {
              let c = pixels[i].baseColor;
              pixels[i].baseColor = [c[0], c[1], Math.min(255, c[2]+100)];
            }
          }
          break;
        case 'boostGreen':
          for(let i=0; i<pixels.length; i++) {
            let c = pixels[i].baseColor;
            pixels[i].baseColor = [c[0], Math.min(255, c[1]+80), c[2]];
          }
          break;
        case 'glitchShift':
          for(let i=0; i<pixels.length; i++) {
            pixels[i].offsetX = Math.sin(time * 20 + i) * 2;
            pixels[i].offsetY = Math.cos(time * 15 + i * 1.5) * 2;
          }
          break;
      }
    }

    // === Основная визуализация ===
    function drawVisual(time, bassLevel) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Рисуем пиксели с небольшим глитчем движения и альфа
      for(let i = 0; i < pixels.length; i++) {
        const p = pixels[i];

        // Смещение в зависимости от синуса и текущих offsetX/offsetY
        const alphaBase = 0.3 + 0.7 * Math.abs(Math.sin(time * 4 + i));
        const xMove = p.offsetX * Math.sin(time * 7 + i);
        const yMove = p.offsetY * Math.cos(time * 6 + i * 1.3);

        // Изменяем прозрачность в такт басу
        const alpha = Math.min(1, alphaBase + bassLevel * 0.8);

        ctx.fillStyle = `rgba(${p.baseColor[0]},${p.baseColor[1]},${p.baseColor[2]},${alpha})`;
        ctx.fillRect(p.x + xMove, p.y + yMove, pixelSize, pixelSize);
      }
    }

    // === Генерация мелодии из текста + эффекты по буквам ===
    function generateMelodyAndEffects(text, speed) {
      // Создаем сид из текста
      const seedNum = cyrb128(text);
      const seedRandom = mulberry32(seedNum);

      // Очистка и инициализация пикселей с новым сидом для базовых цветов
      for(let i=0; i<pixels.length; i++) {
        pixels[i].baseColor = baseColorsPalette[Math.floor(seedRandom()*baseColorsPalette.length)];
        pixels[i].offsetX = (seedRandom() * 2 - 1) * 0.5;
        pixels[i].offsetY = (seedRandom() * 2 - 1) * 0.5;
      }

      // Массив частот по символам
      const freqs = [];
      for(let i=0; i<text.length; i++) {
        const charCode = text.charCodeAt(i);
        // Берём частоту с учетом случайного октава
        freqs.push(charFreq(charCode, Math.floor(seedRandom()*6) - 3));
      }

      // Создаём мелодию с арпеджио и шумом
      const now = audioCtx.currentTime + 0.1;
      let timeCursor = now;

      // Длительность ноты и паузы зависит от speed (темпа)
      const baseDuration = 0.3 / speed;

      for(let i=0; i<freqs.length; i++) {
        playTone(freqs[i], baseDuration * 0.8, timeCursor, 0.15);
        // Периодически добавляем шум для глитча
        if(i % 4 === 0) playNoise(baseDuration * 0.2, timeCursor + baseDuration * 0.5, 0.07);
        timeCursor += baseDuration * 0.9;
      }

      // По буквам запускаем эффекты для пикселей (ограничим максимум 6 эффектов)
      const maxEffects = Math.min(text.length, 6);
      for(let i=0; i<maxEffects; i++) {
        const eff = letterEffect(text[i].toLowerCase(), seedRandom);
        applyEffectToPixels(eff, 0); // time=0 для инициализации эффекта
      }

      // Возвращаем значение баса для визуализации (фиксированное для простоты)
      return 0.6;
    }

    // === Анимация и логика ===
    let bassLevelGlobal = 0;
    let animationId;
    let isPlaying = false;
    let lastTime = 0;
    let speedMultiplier = 1;

    function animate(timeMs) {
      if(!lastTime) lastTime = timeMs;
      const delta = (timeMs - lastTime) / 1000;
      lastTime = timeMs;

      // Обновляем время для эффекта с учетом скорости музыки
      const effectTime = timeMs / 1000 * speedMultiplier;

      drawVisual(effectTime, bassLevelGlobal);

      animationId = requestAnimationFrame(animate);
    }

    // === DOM события ===
    document.getElementById('startBtn').addEventListener('click', () => {
      if(audioCtx.state === 'suspended') audioCtx.resume();

      const text = document.getElementById('inputText').value.trim();
      if(!text) return alert('Напиши что-то, чтобы ссаный питух начал работу!');

      speedMultiplier = parseFloat(document.getElementById('speedRange').value);

      bassLevelGlobal = generateMelodyAndEffects(text, speedMultiplier);

      if(!isPlaying) {
        isPlaying = true;
        lastTime = 0;
        animationId = requestAnimationFrame(animate);
      }
    });

    document.getElementById('speedRange').addEventListener('input', e => {
      const val = e.target.value;
      document.getElementById('speedDisplay').textContent = parseFloat(val).toFixed(2);
    });

  </script>

</body>
</html>
