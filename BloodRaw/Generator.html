<!DOCTYPE HTML>
<meta charset="utf-8">
<title>BloodRaw</title>
<link rel="icon" type="image/x-icon" href="Source/iconblock.ico">

<meta property="og:type" content="website">
<meta property="og:url" content="https://woowz11.github.io/woowzsite/BloodRaw/Main">
<meta property="og:image" content="https://raw.githubusercontent.com/Woowz11/woowzsite/main/BloodRaw/Source/og.png">
<meta name="twitter:card" content="summary_large_image">

<meta property="og:site_name" content="Bloodraw">
<meta property="og:title" content="Minecraft Texture/Resource pack!">
<meta property="og:description" content="">

<link rel="stylesheet" href="Source/css.css">

<style>
html, button{
	font-size   : 1.25em;
	text-shadow : 0.135em 0.125em 0px color-mix(in srgb, currentColor 30%, black);
}

.Container{
	max-width: 1000px;
	margin: 20px auto;
	padding: 20px;
	display: flex;
    flex-direction: column;
    gap: 15px;
}

.Console{
	background: radial-gradient(
		circle at center,
		rgba(0, 10, 0, 0.9 ) 0%  ,
		rgba(0, 5 , 0, 0.85) 40% ,
		rgba(0, 0 , 0, 0.75) 100%
	);
	color: #00ff55;
	font-size: 0.8em;
	line-height: 1.4em;

	padding   : 12px;
	height    : 275px;
	overflow-y: auto;

	outline: 3px solid rgba(0, 0, 0, 0.5);

	text-shadow: 0 0 5px currentColor, 0 0 10px currentColor;
}

.Console p{
	margin: 0;
}
</style>

<link href="../Libs/select2.min.css" rel="stylesheet" />
<script src="../Libs/jquery.min.js"></script>
<script src="../Libs/select2.min.js"></script>

<body id="body"><div class="Container">
	<input type="file" id="PreLoadPack" accept=".zip" style="display: none;">

	<h1>Генератор BloodRaw</h1>

	<div>
		<p>Информация:</p>
		<li><p id="PackVersion">?</p></li>
	</div>

	<div>
		<p>Версия:</p>
		<select id="SelectVersion" style="width: 400px;"></select>
	</div>

	<div style="text-align:center;">
		<button id="B_Generate" onclick="Generate();">Сгенерировать пак</button>
	</div>

	<div>
		<p>Консоль:</p>
		<div class="Console" id="Console"></div>
	</div>

</div></body>

<script src="../source/Logger.js"></script>
<script src="../Libs/jszip.min.js"></script>
<script>

/* Запущен сайт локально?  */ const IsLocal	     = window.location.protocol === "file:";
/* Путь до файла с паком   */ const PackFile     = "https://raw.githubusercontent.com/Woowz11/BloodRaw-Minecraft/refs/heads/main/BloodRaw-Pack.zip";
/* Ссылка на сайт BloodRaw */ const BloodRawLink = "https://woowz11.github.io/woowzsite/BloodRaw/Main";
 
/* Дефолтная текстура */ const DefaultTexture = "R/T/Default.png"
/* Текстура ошибка    */ const ErrorTexture   = "R/T/Error.png"
/* Пустая текстура    */ const EmptyTexture   = "R/T/Empty.png"

/* ======================================================== */

var Console = $("#Console");

Logger.Console = function(Message, Type = 0){
	switch(Type){
		case 0: Logger.Info (Message, null, "color: lime;"); break;
		case 1: Logger.Warn (Message                      ); break;
		case 2: Logger.Error(Message                      ); break;
	}
	if(!InGeneration){ return; }
	Message = "[" + String((Date.now() - GenerationStartTime)).padEnd(4, "-") + "]: " + Message;
	Console.append(`<p${Type !== 0 ? " style=\"color:" + (Type === 1 ? "yellow" : "red") + ";\"" : ""}>${Message}</p>`);
}

Logger.ConsoleWarn = function(Message, Exception){
	Logger.Warn(Message, Exception);
	Logger.Console(Message, 1);
}

Logger.ConsoleError = function(Message, Exception){
	Logger.Error(Message, Exception);
	Logger.Console(Exception.Message  , 2);
	Logger.Console("См. консоль (F12)", 2);
}

/* Более умный JSON.parse */
function JSONParse(Text){
	Text = Text.replace(/\/\*[\s\S]*?\*\//g, "");
	Text = Text.replace(/\/\/.*$/gm        , "");
	
	Text = Text.replace(/^\uFEFF/, '');
    Text = Text.replace(/[\x00-\x1F\x7F]/g, c => c === '\n' || c === '\r' ? c : '');
	
	return JSON.parse(Text);
}

/* Останавливает поток на определённое кол-во миллисекунд */
function Sleep(MS){
	return new Promise(R => setTimeout(R, MS));
}

/* Обновляет строку */
function UpdateString(String){
	const Replacements = {
		Version         : PackVersion,
        MinecraftVersion: SelectedVersion,
        Author          : Author,
        License         : License,
        Link            : BloodRawLink
	};

	return String.replace(/<([A-Za-z0-9_]+)>/g, (M, K) => Replacements[K] ?? "undefined");
}

function Lerp(A, B, T){ return A + (B - A) * T; }

/* ======================================================== */

/* Информация об паке (ZIP файл результат) */
var Pack;

/* Пак генерируется? */
var InGeneration = false;

/* Время начала генерации */
var GenerationStartTime;

/* Генерация пака */
async function Generate(){
	try{
		if(!PreLoaded){ throw new Error("Пак ещё не был пред-загружен!"); }
		if(InGeneration){ throw new Error("Пак уже генерируется!"); }
		Console.empty();
		
		InGeneration = true;
		GenerationStartTime = Date.now();
		Logger.Console("Начало генерации пака!");
		
		Pack = new JSZip();
		
		await ApplyGenerator(PackVersions[SelectedVersion]);
		
		Logger.Console("Скачивание...");
		
		const Blob = await Pack.generateAsync({ type: "blob" });
		const A = document.createElement("a");
		A.href = URL.createObjectURL(Blob);
		A.download = "Bloodraw " + SelectedVersion + ".zip";
		document.body.appendChild(A);
		A.click();
		document.body.removeChild(A);
		URL.revokeObjectURL(A.href);
		
		Logger.Console("Конец генерации пака!");
		InGeneration = false;
		Pack = null;
	}catch(e){
		if(InGeneration){ 
			Logger.ConsoleError("Произошла ошибка при генерации пака!", e);
		}else{
			Logger.Fatal("Произошла ошибка при генерации пака!", e);
		}
	}
}

/* Применить генератор */
async function ApplyGenerator(Generator){
	try{
		var Files = Generator["Files"];
		
		Logger.Console("Применение генератора. ID: " + Generator["ID"]);
		
		for(const Path of Object.keys(Files)){
			var Content = await GenerateFile(Path, Files[Path]);
			
			if(Content instanceof Texture){
				Content = Content.ToBlob();
			}
			
			Pack.file(Path, Content);
		}
	}catch(e){
		throw new Error("Произошла ошибка с генератором!", e);
	}
}

/* Применяет модификатор */
async function ApplyAction(Content, Type, Info){
	try{
		Logger.Console("Применение модификатора [" + Type + "]...");
	
		if(Type === "Background"){
			Content.Background(Info[0]);
		}else if(Type === "Put"){
			var T     = await GenerateFile(Info[0]);
			var X     = Info[1] || 0;
			var Y     = Info[2] || 0;
			var Blend = Info[3] || "alpha";
			
			Content.Put(T, X, Y, Blend);
		}else if(Type === "Frame"){
			var Index = Info[0] || 0;
			
			Content.Frame(Index);
		}else if(Type === "Resize"){
			var W = Info[0];
			var H = Info[1];
			var Smooth = Info[2] || true;
			
			Content.Resize(W, H, Smooth);
		}else if(Type === "Crop"){
			var X = Info[0];
			var Y = Info[1];
			var W = Info[2];
			var H = Info[3];
			
			Content.Crop(X, Y, W, H);
		}else{
			Logger.ConsoleWarn("Тип модификатора [" + Type + "], не найден!");
		}
		
		return Content;
	}catch(e){
		throw new Error("Произошла ошибка при применении модификатора [" + Type + "]!", e);
	}
}

/* Применение модификаторов */
async function ApplyActions(Content, Actions){
	try{
		if(!Actions || !Actions.length){ return Content; }
		
		Content = Content.Clone();
		
		for(var Action of Actions){ Content = await ApplyAction(Content, Action[0], Action.slice(1)); }
		
		return Content;
	}catch(e){
		throw new Error("Произошла ошибка при применении модификаторов!", e);
	}
}

/* Содержимое сгенерированного файла */
async function GenerateFile(Path, Info){
	var MemoryFile = Path && !Info;
	if(MemoryFile){ Info = Path; Path = null; }

	try{
		if(MemoryFile){
			Logger.Console("Генерация файла в памяти...");
		}else{
			Logger.Console("Генерация [" + Path + "]...");
		}
		
		const GenerateType = Info[0];
		var Actions = null;
		
		var Result = "Не найден тип генерации [" + GenerateType + "]!";
		
		if(GenerateType === "Texture"){
			var FilePath = Info[1];
			Actions = Info[2] || null;
			Result = await GetTexture(FilePath);
		}else if(GenerateType === "Create"){
			if(typeof Info[1] === "number" && typeof Info[2] === "number"){
				var W = Info[1];
				var H = Info[2];
				var Color = Info[3] || "transparent";
				Actions = Info[4] || null;
				
				Result = new Texture(W, H, Color);
			}else{
				var Content = Info[1];
				Actions = Info[2] || null;
				Result = UpdateString(Content);
			}
		}else if(GenerateType === "Atlas"){
			var AtlasInfo = Info[1];
			Actions = Info[2] || null;
			Result = await GenerateAtlas(AtlasInfo);
		}else if(GenerateType === "Painting"){
			var W = Info[1];
			var H = Info[2];
			Actions = Info[3] || null;
			Result = await GeneratePainting(W, H);
		}else{
			Logger.ConsoleWarn("Тип файла [" + GenerateType + "], не найден!");
		}
		
		Result = await ApplyActions(Result, Actions);
		return Result;
	}catch(e){
		Logger.ConsoleError("Произошла ошибка при генерации файла " + (MemoryFile ? "в памяти" : "[" + Path + "]") + "!", e);
		return "Произошла ошибка при генерации этого файла...";
	}
}

/* ======================================================== */

/* Генерация атласа */
async function GenerateAtlas(Info){
	try{
		var Empty = Info["Empty"] ? await GenerateFile(Info["Empty"]) : false;
		var Size  = Info["Size" ] || [1 , 1 ];
		var Scale = Info["Scale"] || [16, 16];
		var W     = Size[0];
		var H     = Size[1];
		
		if(W <= 0 || H <= 0){ throw new Error("Размер атласа <= 0!\nW: " + W + " | H: " + H); }
		
		var Atlas = new Texture(W * Scale[0], H * Scale[1]);
		
		for(var Y = 1; Y < (H + 1); Y++){
			for(var X = 1; X < (W + 1); X++){
				try{
					var Tile = null;
					var Y_ = Info[Y];
					if(Y_){
						var X_ = Y_[X];
						if(X_ != undefined){
							if(X_ === false){
								Tile = false;
							}else{
								Tile = await GenerateFile(X_);
							}
						}
					}
					
					if(Tile != false){
						Atlas.Set(Tile ? Tile : Empty, (X - 1) * Scale[0], (Y - 1) * Scale[1]);
					}
				}catch(e){
					Logger.Error("Произошла ошибка генерации тайтла [" + X + ":" + Y + "] у атласа!");
				}
			}
		}
		
		return Atlas;
	}catch(e){
		throw new Error("Произошла ошибка при генерации атласа!", e);
	}
}

/* Генерация картины */
async function GeneratePainting(W, H){
	try{
		if(W === true && !H){ return await GetTexture("Changelog.texture"); }
	
		var FrameTexture = "R/T/ART/Frame_" + W + H + ".png";
	
		return await GetTexture(FrameTexture);
	}catch(e){
		throw new Error("Произошла ошибка при генерации картины " + W + "x" + H + "!", e);
	}
}

/* ======================================================== */

class Texture{
	constructor(W, H, Content = null){
		try{
			if(W <= 0 || H <= 0){ throw new Error("Размеры текстуры <= 0!"); }
			
			this.W = W;
			this.H = H;
			
			this.C = document.createElement("Canvas");
			this.C.width = W; this.C.height = H;
			this.CTX = this.C.getContext("2d");
			
			this.Content = new Uint8ClampedArray(W * H * 4);
			
			this.Fill(Content);
		}catch(e){
			throw new Error("Произошла ошибка при создании текстуры! new Texture(" + W + ", " + H + ", ...);", e);
		}
	}
	
	/* Полностью закрасить текстуру */
	Fill(Content){
		try{
			var Data = Content;
			if(Content instanceof Texture){ Data = Content.Content; }
			
			if(Data instanceof Uint8ClampedArray){
				if(Data.length !== this.Content.length){ throw new Error("Размер Content не совпадает с требуемым!"); }
				this.Content.set(Data);
				this.__UpdateCanvas();
			}else{
				this.CTX.clearRect(0, 0, this.W, this.H);
				this.CTX.fillStyle = Data || "transparent";
				this.CTX.fillRect(0, 0, this.W, this.H);
				this.__UpdateContent();
			}
			
			return this;
		}catch(e){
			throw new Error("Произошла ошибка при заливке текстуры [" + this + "]!", e);
		}
	}
	
	/* Добавляет текстуру на текстуру */
	Put(Content, X = 0, Y = 0, Blend = "alpha"){
		if(Content === false){ return; }
	
		const PrevBlend = this.CTX.globalCompositeOperation;
		if(Blend !== "alpha"){ this.CTX.globalCompositeOperation = Blend; }
	
		try{
			if(X < 0 || Y < 0){ throw new Error("Позиция < 0!"); }
			if(X > this.W || Y > this.H){ throw new Error("Позиция > размера текстуры!"); }
		
			if(Blend === "alpha"){
				var Data;
				if(Content instanceof Texture){
					Data = Content.Content;
				}else if(Content instanceof Uint8ClampedArray){
					Data = Content;
				}else{
					throw new Error("Нужен Texture!");
				}
				
				var W = Content.W || this.W;
				var H = Content.H || this.H;
				
				for(var Y_ = 0; Y_ < H; Y_++){
					for(var X_ = 0; X_ < W; X_++){
						const CI = ((Y_ + Y) * this.W + (X_ + X)) * 4;
						const DI = (Y_ * W + X_) * 4;
						
						const BaseR = this.Content[CI + 0]      ;
						const BaseG = this.Content[CI + 1]      ;
						const BaseB = this.Content[CI + 2]      ;
						const BaseA = this.Content[CI + 3] / 255;

						const OverR = Data[DI + 0]      ;
						const OverG = Data[DI + 1]      ;
						const OverB = Data[DI + 2]      ;
						const OverA = Data[DI + 3] / 255;

						const OutA = OverA + BaseA * (1 - OverA);
						if (OutA === 0){ continue; }

						this.Content[CI + 0] = Math.round((OverR * OverA + BaseR * BaseA * (1 - OverA)) / OutA);
						this.Content[CI + 1] = Math.round((OverG * OverA + BaseG * BaseA * (1 - OverA)) / OutA);
						this.Content[CI + 2] = Math.round((OverB * OverA + BaseB * BaseA * (1 - OverA)) / OutA);
						this.Content[CI + 3] = Math.round(OutA * 255);
					}
				}
				
				this.__UpdateCanvas();
			}else{
				if(Content instanceof Texture){
					this.CTX.drawImage(Content.C, X, Y);
				}else if(Content instanceof Uint8ClampedArray){
					this.CTX.putImageData(new ImageData(Content, this.W, this.H), X, Y);
				}else{
					throw new Error("Нужен Texture!");
				}
				
				this.__UpdateContent();
			}
			
			return this;
		}catch(e){
			throw new Error("Произошла ошибка при добавлении текстуры на текстуру [" + this + "]! Put(..., " + X + ", " + Y + ");", e);
		}finally{
			if(Blend !== "alpha"){ this.CTX.globalCompositeOperation = PrevBlend; }
		}
	}
	
	/* Заменяет текстуру */
	Set(Content, X = 0, Y = 0){ return this.Put(Content, X, Y, "source-over"); }
	
	/* Устанавливает цвет заднего фона */
	Background(Color = "white"){
		try{
			var Current = new Uint8ClampedArray(this.Content);
			this.Fill(Color        );
			this.Put (Current, 0, 0);
			
			return this;
		}catch(e){
			throw new Error("Произошла ошибка при установке цвета заднего фона текстуре [" + this + "]! Background(" + Color + ");", e);
		}
	}
	
	/* Обрезать текстуру */
	Crop(X, Y, W, H){
		try{
			if(X < 0 || Y < 0 || X + W > this.W || Y + H > this.H){ throw new Error("Параметры выходят за пределы текстуры!"); }
			
			const NewContent = new Uint8ClampedArray(W * H * 4);

			for(var Y_ = 0; Y_ < H; Y_++){
				for(var X_ = 0; X_ < W; X_++){
					const CI = ((Y_ + Y) * this.W + (X_ + X)) * 4;
					const DI = (Y_ * W + X_) * 4;

					NewContent[DI + 0] = this.Content[CI + 0];
					NewContent[DI + 1] = this.Content[CI + 1];
					NewContent[DI + 2] = this.Content[CI + 2];
					NewContent[DI + 3] = this.Content[CI + 3];
				}
			}

			this.Content = NewContent;
			this.W = W; this.H = H;
			
			this.C.width = W; this.C.height = H;
			this.CTX.putImageData(new ImageData(this.Content, W, H), 0, 0);

			return this;
		}catch(e){
			throw new Error("Произошла ошибка при обрезке текстуры [" + this + "]! Crop(" + X + ", " + Y + ", " + W + ", " + H + ");", e);
		}
	}
	
	/* Получает кадр из анимированной текстуры */
	Frame(Index = 0){
		try{
			const TotalFrames = Math.floor(this.H / this.W);
			
			if(Index < 0 || Index >= TotalFrames){ throw new Error("Индекс кадра выходит за пределы анимации!"); }
			
			return this.Crop(Index * this.W, 0, this.W, this.W);
		}catch(e){
			throw new Error("Произошла ошибка при получении кадра из анимации у текстуры [" + this + "]! Frame(" + Index + ");", e);
		}
	}
	
	/* Изменить размер изображения */
	Resize(W, H, Smooth = true){
		const PrevISE = this.CTX.imageSmoothingEnabled;
		const PrevISQ = this.CTX.imageSmoothingQuality;
		
		this.CTX.imageSmoothingEnabled = Smooth;
		this.CTX.imageSmoothingQuality = Smooth ? "high" : "low";
	
		try{
			if(W <= 0 || H <= 0){ throw new Error("Новый размер <= 0!"); }
			
			const OW = this.W;
			const OH = this.H;
			const NewContent = new Uint8ClampedArray(W * H * 4);

			for(var Y = 0; Y < H; Y++){
				for(var X = 0; X < W; X++){
					const NI = (Y * W + X) * 4;

					if(Smooth){
						const GX = (X + 0.5) * OW / W - 0.5;
						const GY = (Y + 0.5) * OH / H - 0.5;
						const GXI = Math.floor(GX);
						const GYI = Math.floor(GY);
						const DX = GX - GXI;
						const DY = GY - GYI;

						for(var P = 0; P < 4; P++){
							const P00 = this.Content[((Math.min(GYI    , OH - 1) * OW + Math.min(GXI    , OW - 1)) * 4) + P];
							const P10 = this.Content[((Math.min(GYI    , OH - 1) * OW + Math.min(GXI + 1, OW - 1)) * 4) + P];
							const P01 = this.Content[((Math.min(GYI + 1, OH - 1) * OW + Math.min(GXI    , OW - 1)) * 4) + P];
							const P11 = this.Content[((Math.min(GYI + 1, OH - 1) * OW + Math.min(GXI + 1, OW - 1)) * 4) + P];

							const P0 = P00 * (1 - DX) + P10 * DX;
							const P1 = P01 * (1 - DX) + P11 * DX;
							NewContent[NI + P] = Math.round(P0 * (1 - DY) + P1 * DY);
						}
					} else {
						const OX = Math.floor(X * OW / W);
						const OY = Math.floor(Y * OH / H);
						const OI = (OY * OW + OX) * 4;
						NewContent[NI + 0] = this.Content[OI + 0];
						NewContent[NI + 1] = this.Content[OI + 1];
						NewContent[NI + 2] = this.Content[OI + 2];
						NewContent[NI + 3] = this.Content[OI + 3];
					}
				}
			}

			this.W = W; this.H = H;
			this.Content = NewContent;

			this.C.width = W; this.C.height = H;
			this.CTX.putImageData(new ImageData(this.Content, W, H), 0, 0);

			return this;
		}catch(e){
			throw new Error("Произошла ошибка при изменении размера у текстуры [" + this + "]! Resize(" + W + ", " + H + ", " + Smooth + ");", e);
		}finally{
			this.CTX.imageSmoothingEnabled = PrevISE;
			this.CTX.imageSmoothingQuality = PrevISQ;
		}
	}
	
	/* Клонирует текстуру */
	Clone(){
		return new Texture(this.W, this.H, this.Content);
	}
	
	/* ======================================================== */
	
	async ToBlob(){
		return await new Promise(R => this.C.toBlob(R, "image/png"));
	}
	
	__UpdateCanvas(){
		this.CTX.putImageData(new ImageData(this.Content, this.W, this.H), 0, 0);
	}
	
	__UpdateContent(){
		this.Content.set(this.CTX.getImageData(0, 0, this.W, this.H).data);
	}
	
	toString(){
		return "Texture[" + this.W + "x" + this.H + "]";
	}
}

/* ======================================================== */

/* Получить файл */
async function GetFile(Path, ThatTexture = false){
	Path = Path.replace(/\\/g, "/").replace(/\/+/g, "/");
	
	if(__GetFileCache[Path]){ return __GetFileCache[Path]; }
	
	var File = PackFiles[Path];
	if(!File){ throw new Error("Файл [" + Path + "] не найден!"); }
	
	if(ThatTexture){
		const Extension = Path.split(".").pop().toLowerCase();
		
		if(Extension === "texture"){
			const TextureInfo = await FileContentJSON(File);
			
			File = await GenerateFile(Path, TextureInfo);
		}else{
			const PNGContent = await FileContentByte(File);
		
			const Blob_  = new Blob([PNGContent], { type: "image/png" });
			
			const { W, H, Content } = await new Promise((R, E) => {
				const Image_ = new Image();
				Image_.onload = () => {
					const C = document.createElement("canvas");
					C.width = Image_.width;
					C.height = Image_.height;
					const CTX = C.getContext("2d");
					CTX.drawImage(Image_, 0, 0);
					const ImageData = CTX.getImageData(0, 0, Image_.width, Image_.height);
					URL.revokeObjectURL(Image_.src);
					R({ W: Image_.width, H: Image_.height, Content: ImageData.data });
				};
				Image_.onerror = E;
				Image_.src = URL.createObjectURL(Blob_);
			});
			
			File = new Texture(W, H, new Uint8ClampedArray(Content));
		}
	}
	
	__GetFileCache[Path] = File;
	return File;
}
const __GetFileCache = {};

/* Получить текстуру */
async function GetTexture(Path){ return await GetFile(Path, true); }

/* Получить содержимое файла в виде JSON */
async function FileContentJSON(File){
	try{
		var Text = await FileContent(File);
		return JSONParse(Text);
	}catch(e){
		throw new Error("Произошла ошибка при чтении файла [" + File.name + "], в формате JSON!", e);
	}
}

const __FilesContentString = {};
const __FilesContentBytes  = {};

/* Получить строковое содержимое файла */
async function FileContent(File){
	if(__FilesContentString[File.name]){ return __FilesContentString[File.name]; }
	
	try{
		const Text = await File.async("text");
		__FilesContentString[File.name] = Text;
		return Text;
	}catch(e){
		throw new Error("Произошла ошибка при чтении файла [" + File.name + "]!", e);
	}
}

/* Получить байтовое содержимое файла */
async function FileContentByte(File){
	if(File instanceof Texture){ return File.Content; }
	if(__FilesContentBytes[File.name]){ return __FilesContentBytes[File.name]; }
	
	try{
		const Buf = await File.async("uint8array");
		const Bytes = new Uint8Array(Buf);
		__FilesContentBytes[File.name] = Bytes;
		return Bytes;
	}catch(e){
		throw new Error("Произошла ошибка при чтении файла [" + File.name + "], в формате Bytes!", e);
	}
}

/* ======================================================== */

/* Файлы пака (Все файлы) */
const PackFiles = {};
/* Папки пака (Файлы внутри папок) */
const PackFolders = {};

/* Информация об паке */
var PackInfo;

/* Автор пака */
var Author;

/* Лицензия пака */
var License;

/* Версия пака */
var PackVersion;

/* Доступные версии пака */
const PackVersions = {}

/* Выбранная версия */
var SelectedVersion = null;

/* Получает разную информацию из пака */
async function LoadPackInformation(){
	try{
		for(const Path of Object.keys(PackFiles)){
			const LastSlash = Path.lastIndexOf("/");
			const Folder    = LastSlash === -1 ? ""   : Path.substring(0,  LastSlash);
			
			if(!PackFolders[Folder]){ PackFolders[Folder] = []; }
			PackFolders[Folder].push(PackFiles[Path]);
		}
		
		PackInfo = await FileContentJSON(await GetFile("Info.json"));
		Author   = PackInfo["Author" ];
		License  = PackInfo["License"];
		
		try{
			const Response = await fetch("https://api.github.com/repos/Woowz11/BloodRaw-Minecraft/commits/main");
			if(!Response.ok){ throw new Error("Ошибка загрузки: " + Response.status); }
			
			const Commit = await Response.json();
			
			PackVersion = Commit.commit.message.split("\n")[0];
		}catch(e){
			Logger.Error("Произошла ошибка при получении версии репозитория!", e);
			PackVersion = "Error";
		}

		$("#PackVersion").text(PackVersion);
		
		for(const File of PackFolders["Generators"]){
			var Version = File.name.split("/").pop();
			const LastDot = Version.lastIndexOf(".");
			if(LastDot !== -1){ Version = Version.substring(0, LastDot); }
			
			var VersionInfo = await FileContentJSON(File);
			
			PackVersions[Version] = VersionInfo;
		}
	}catch(e){
		throw new Error("Произошла ошибка при загрузке информации об паке!", e);
	}
}

/* Вызывается после пре-загрузки */
async function PreLoadAfter(){
	if(!StartPreLoaded){ return; }
	try{
		await LoadPackInformation();
	
		const SelectVersion = $("#SelectVersion");
		
		SelectVersion.html(Object.keys(PackVersions).map(V => `<option value="${V}">${V} : ${V.ID}</option>`).join(""));
		SelectVersion.select2({
			placeholder: "Выберите версию",
			allowClear: true
		});
		
		SelectedVersion = SelectVersion.val();
		
		SelectVersion.on('change', function(){ SelectedVersion = SelectVersion.val(); });
		
		PreLoaded = true;
	}catch(e){
		throw new Error("Произошла ошибка после пред-загрузки!", e);
	}
}

/* Начата пред-загрузка пака? */
var StartPreLoaded = false;
/* Пак пред-загружен? */
var PreLoaded = false;
/* Пре-загрузка пака (Только один раз!) */
async function PreLoad(Buf){
	if(StartPreLoaded || PreLoaded){ return; } StartPreLoaded = true;
	try{
		const ZIP = await JSZip.loadAsync(Buf);

		for (const Name of Object.keys(ZIP.files)) {
			const File = ZIP.files[Name];
			if(File.dir){ continue; }

			File.name = File.name.replace(/\\/g, "/").replace(/\/+/g, "/");
			PackFiles[Name.replace(/\\/g, "/").replace(/\/+/g, "/")] = File;
		}
		
		await PreLoadAfter();
	} catch(e){
		throw new Error("Произошла ошибка при пред-загрузке пака!", e);
	}
}

/* Вызывается при запуске сайта */
function Awake(){
	const PreLoadPack = $("#PreLoadPack");
	if (IsLocal){
		PreLoadPack.on("change", async (EV) => {
			try{
				const File = EV.target.files[0];
				if(!File){ return; }
				const Buf = await File.arrayBuffer();
				await PreLoad(Buf);
			}catch(e){
				Logger.Fatal("Произошла ошибка при получении пака с компьютера!", e);
			}
		});
		
		PreLoadPack.css("display", "unset");
	}else{
		(async () => {
			try{
				const response = await fetch(PackFile);
				if (!response.ok){ throw new __Error("Ошибка загрузки: " + response.status); }
				const Buf = await response.arrayBuffer();
				await PreLoad(Buf);
			}catch(e){
				Logger.Fatal("Произошла ошибка при получении пака с raw.githubusercontent.com!", e);
			}
		})();
	}
}
Awake();

/* Вызывается когда сайт загружен */
function SiteLoaded(){
	try{
	
	}catch(e){
		Logger.Fatal("Произошла ошибка при загрузке сайта!", e);
	}
}

$(document).ready(function(){ SiteLoaded(); });

</script>