<!DOCTYPE HTML>
<meta charset="utf-8">
<title>BloodRaw</title>
<link rel="icon" type="image/x-icon" href="Source/iconblock.ico">

<meta property="og:type" content="website">
<meta property="og:url" content="https://woowz11.github.io/woowzsite/BloodRaw/Main">
<meta property="og:image" content="https://raw.githubusercontent.com/Woowz11/woowzsite/main/BloodRaw/Source/og.png">
<meta name="twitter:card" content="summary_large_image">

<meta property="og:site_name" content="Bloodraw">
<meta property="og:title" content="Minecraft Texture/Resource pack!">
<meta property="og:description" content="">

<link rel="stylesheet" href="Source/css.css">

<style>
html, button{
	font-size   : 1.25em;
	text-shadow : 0.135em 0.125em 0px color-mix(in srgb, currentColor 30%, black);
}

.Container{
	max-width: 1000px;
	height: 100vh;
	margin: 0 auto;
	display: flex;
    flex-direction: column;
    gap: 15px;
}

.Console{
	background: radial-gradient(
		circle at center,
		rgba(0, 10, 0, 0.9 ) 0%  ,
		rgba(0, 5 , 0, 0.85) 40% ,
		rgba(0, 0 , 0, 0.75) 100%
	);
	color: #00ff55;
	font-size: 0.8em;
	line-height: 1.4em;

	padding   : 12px;
	overflow-y: auto;

	outline: 3px solid rgba(0, 0, 0, 0.5);

	text-shadow: 0 0 5px currentColor, 0 0 10px currentColor;
}

.Console p{
	margin: 0;
}

.InfoBox {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 15px 20px;
	background: linear-gradient(135deg, rgba(40,40,40,0.95), rgba(20,20,20,0.95));
	border: 3px solid rgba(255, 0, 0, 0.5);
	box-shadow: 0 0 15px rgba(255,0,0,0.3);
	gap: 20px;
}
</style>

<link href="../Libs/select2.min.css" rel="stylesheet" />
<script src="../Libs/jquery.min.js"></script>
<script src="../Libs/select2.min.js"></script>

<body id="body"><div class="Container">
	<input type="file" id="PreLoadPack" accept=".zip" style="display: none;">

	<h1>Генератор BloodRaw</h1>

	<div class="InfoBox">
		<div>
			<p><b>Информация:</b></p>
			<li><p id="PackVersion">?</p></li>
		</div>
		<img id="ChangelogImage" src="https://woowz11.github.io/woowzsite/source/specialforrandomsite/cowfly.png" width="120px" height="120px" style="box-shadow: 0 0 10px rgba(255,0,0,0.4);" alt="Changelog картинка">
	</div>

	<center><div>
		<p>Версия:</p>
		<select id="SelectVersion" style="width: 400px;"></select>
	</div></center>

	<div style="text-align:center; padding-top: 20px;">
		<button id="B_Generate" onclick="Generate();">Сгенерировать пак</button>
	</div>

	<div>
		<p>Консоль:</p>
		<div class="Console" style="min-height: 100%;" id="Console"></div>
	</div>

</div></body>

<script src="../source/Logger.js"></script>
<script src="../Libs/jszip.min.js"></script>
<script>

/* Запущен сайт локально?  */ const IsLocal	     = window.location.protocol === "file:";
/* Путь до файла с паком   */ const PackFile     = "https://raw.githubusercontent.com/Woowz11/BloodRaw-Minecraft/refs/heads/main/BloodRaw-Pack.zip";
/* Ссылка на сайт BloodRaw */ const BloodRawLink = "https://woowz11.github.io/woowzsite/BloodRaw/Main";
 
/* Дефолтная текстура */ const DefaultTexture   = "R/T/Default.png"
/* Текстура ошибка    */ const ErrorTexture     = "R/T/Error.png"
/* Пустая текстура    */ const EmptyTexture     = "R/T/Empty.png"
/* Текстура Changelog */ const ChangelogTexture = "Changelog.texture";

/* ======================================================== */

var Console = $("#Console");

Logger.Console = function(Message, Type = 0){
	switch(Type){
		case 0: Logger.Info (Message, null, InGeneration ? "color: lime;" : undefined); break;
		case 1: Logger.Warn (Message                      ); break;
		case 2: Logger.Error(Message                      ); break;
	}
	if(!InGeneration){ return; }
	Message = "[" + String((Date.now() - GenerationStartTime)).padEnd(4, "-") + "]: " + Message;
	Console.append(`<p${Type !== 0 ? " style=\"color:" + (Type === 1 ? "yellow" : "red") + ";\"" : ""}>${Message}</p>`);
}

Logger.ConsoleWarn = function(Message, Exception){
	Logger.Warn(Message, Exception);
	Logger.Console(Message, 1);
}

Logger.ConsoleError = function(Message, Exception){
	Logger.Error(Message, Exception);
	Logger.Console(Exception.Message  , 2);
	Logger.Console("См. консоль (F12)", 2);
}

/* Более умный JSON.parse */
function JSONParse(Text){
	Text = Text.replace(/\/\*[\s\S]*?\*\//g, "");
	Text = Text.replace(/\/\/.*$/gm        , "");
	
	Text = Text.replace(/^\uFEFF/, '');
    Text = Text.replace(/[\x00-\x1F\x7F]/g, c => c === '\n' || c === '\r' ? c : '');
	
	if(__JSONParse[Text]){ return DeepClone(__JSONParse[Text]); }
	
	var Result = JSON.parse(Text);
	__JSONParse[Text] = Result;
	
	return Result;
}
var __JSONParse = {};

/* Останавливает поток на определённое кол-во миллисекунд */
function Sleep(MS){
	return new Promise(R => setTimeout(R, MS));
}

/* Обновляет строку */
function UpdateString(String){
	const Replacements = {
		Version         : PackVersion,
        MinecraftVersion: SelectedVersion,
        Author          : Author,
        License         : License,
        Link            : BloodRawLink,
		GitHub          : "https://github.com/Woowz11",
		Generator       : "https://woowz11.github.io/woowzsite/BloodRaw/Generator",
		Discord         : "woowz11",
		G_TotalFiles    : (BuildFile ? TotalFiles + 1 : TotalFiles),
		G_Time          : GenerationTime
	};

	return String.replace(/<([A-Za-z0-9_]+)>/g, (M, K) => Replacements[K] ?? "undefined");
}

/* Обновляет цвет */
function UpdateColor(Color){
	return Color in __Colors ? __Colors[Color] : Color;
}
var __Colors = {};

/* Конвертация цвета в байты */
function CalculateColor(Color){
	try{
		if(typeof Color !== "string"){ return Color; }
	
		if(!CalculateColor.CTX){
			const C = document.createElement("canvas");
			C.width = 1; C.height = 1;
			CalculateColor.CTX = C.getContext("2d");
		}
	
		Color = UpdateColor(Color);
		
		CalculateColor.CTX.clearRect(0, 0, 1, 1);
		CalculateColor.CTX.fillStyle = Color;
		CalculateColor.CTX.fillRect(0, 0, 1, 1);
		return CalculateColor.CTX.getImageData(0, 0, 1, 1).data;
	}catch(e){
		throw new Error("Произошла ошибка при расчёте цвета");
	}
}

/* Глубокое копирование объекта */
function DeepClone(Obj){
	if(Obj === null || typeof Obj !== "object"){ return Obj; }
	
	if(Array.isArray(Obj)){ return Obj.map(DeepClone); }
	if(ArrayBuffer.isView(Obj)){ return new Obj.constructor(Obj); }
	
	const Clone = {};
	for(const Key in Obj){
		if(Object.prototype.hasOwnProperty.call(Obj, Key)){
			Clone[Key] = DeepClone(Obj[Key]);
		}
	}
	return Clone;
}

function Lerp(A, B, T){ return A + (B - A) * T; }
function Clamp(N, Min, Max){ return N <= Min ? Min : (N >= Max ? Max : N); }

/* ======================================================== */

/* Информация об паке (ZIP файл результат) */
var Pack;

/* Пак генерируется? */
var InGeneration = false;

/* Время начала генерации */
var GenerationStartTime;

/* Всего файлов */
var TotalFiles;

/* Сколько времени заняла генерация */
var GenerationTime;

/* Генерация пака */
async function Generate(){
	try{
		if(!PreLoaded){ throw new Error("Пак ещё не был пред-загружен!"); }
		if(InGeneration){ throw new Error("Пак уже генерируется!"); }
		Console.empty();
		
		InGeneration = true;
		GenerationStartTime = Date.now();
		Logger.Info(":" + "=".repeat(50) + ":");
		Logger.Console("Начало генерации пака!");
		
		Pack = new JSZip();
		
		TotalFiles = 0;
		
		__AllPaintings = AllPaintings;
		
		var VersionGenerator = PackVersions[SelectedVersion];
		await ApplyGenerator(await LoadGenerator(VersionGenerator[0], VersionGenerator[1]));
		
		GenerationTime = Date.now() - GenerationStartTime;
		
		if(BuildFile){
			Logger.Console("Применение BuildFile...");
			var BuildFile_ = await GenerateFile(BuildFile[0], BuildFile[1], true);
			await AddFileToPack(BuildFile[0], BuildFile_);
		}
		
		Logger.Console("Скачивание...");
		
		const Blob = await Pack.generateAsync({ type: "blob" });
		const A = document.createElement("a");
		A.href = URL.createObjectURL(Blob);
		A.download = "Bloodraw " + SelectedVersion + ".zip";
		document.body.appendChild(A);
		A.click();
		document.body.removeChild(A);
		URL.revokeObjectURL(A.href);
		
		Logger.Console("Конец генерации пака!");
		InGeneration = false;
		BuildFile = null;
		Pack = null;
	}catch(e){
		if(InGeneration){ 
			Logger.ConsoleError("Произошла ошибка при генерации пака!", e);
		}else{
			Logger.Fatal("Произошла ошибка при генерации пака!", e);
		}
	}
}

/* Добавляет файл паку */
async function AddFileToPack(Path, Content){
	try{
		if(Content === null){ return; }
		
		/* Это текстура? */
		if(Content instanceof Texture){
			Content = await Content.ToBlob();
		}
		
		/* Это JSZipFile? */
		if(Content instanceof Object && Content.name != null && Content.dir != null && Content.date != null){
			Content = await FileContentByte(Content);
		}
		
		Pack.file(Path, Content); TotalFiles++;
	}catch(e){
		throw new Error("Произошла ошибка при добавлении файла [" + Path + "] паку!", e);
	}
}

/* Применить генератор */
async function ApplyGenerator(Generator){
	try{
		var Files = Generator["Files"];
		
		Logger.Console("Применение генератора [" + Generator["Name"] + "]");
		
		var __Info = Generator["__Info"] || {};
		
		var Parent = __Info["Parent"] || null;
		if(Parent){
			Logger.Console("Родитель [" + Parent + "]");
		}
		
		var Added = __Info["Added"] || [];
		for(var Added_ of Added){
			Logger.Console("Добавлено к генератору [" + Added_ + "]");
		}
		
		for(const Path of Object.keys(Files)){
			var Content = await GenerateFile(Path, Files[Path]);
			await AddFileToPack(Path, Content);
		}
	}catch(e){
		throw new Error("Произошла ошибка с генератором!", e);
	}
}

/* Применяет модификатор */
async function ApplyAction(Content, Type, Info){
	try{
		Logger.Console("Применение модификатора [" + Type + "]...");
	
		if(Type === "Background"){
			Content.Background(Info[0]);
		}else if(Type === "Put"){
			var T     = await GenerateFile(Info[0]);
			var X     = Info[1] || 0;
			var Y     = Info[2] || 0;
			var Blend = Info[3] || "alpha";
			
			Content.Put(T, X, Y, Blend);
		}else if(Type === "Frame"){
			var Index = Info[0] || 0;
			
			Content.Frame(Index);
		}else if(Type === "Resize"){
			var W = Info[0];
			var H = Info[1] || W;
			var Smooth = Info[2] || true;
			
			Content.Resize(W, H, Smooth);
		}else if(Type === "Crop"){
			var X = Info[0];
			var Y = Info[1] || X;
			var W = Info[2];
			var H = Info[3] || W;
			
			Content.Crop(X, Y, W, H);
		}else if(Type === "Gradient"){
			var Gradient = await GenerateFile(Info[0]);
			
			Content.Gradient(Gradient);
		}else if(Type === "Multiply"){
			var Color = Info[0];
			
			Content.Multiply(Color);
		}else if(Type === "Fixed"){
			var R = Info[0] || null;
			var G = Info[1] || null;
			var B = Info[2] || null;
			var A = Info[3] || null;
		
			Content.Fixed(R, G, B, A);
		}else if(Type === "NewSize"){
			var W = Info[0];
			var H = Info[1];
			
			Content.NewSize(W, H);
		}else if(Type === "Flip"){
			var X = Info[0] || false;
			var Y = Info[1] || false;
			
			Content.Flip(X, Y);
		}else if(Type === "Trim"){
			var R = Info[0] || null;
			var G = Info[1] || null;
			var B = Info[2] || null;
			var A = Info[3] || null;
			
			Content.Trim(R, G, B, A);
		}else if(Type === "Move"){
			var X = Info[0] || 0;
			var Y = Info[1] || 0;
			
			Content.Move(X, Y);
		}else if(Type === "Invert"){
			var R = Info[0] || true;
			var G = Info[1] || true;
			var B = Info[2] || true;
			var A = Info[3] || false;
			
			Content.Invert(R, G, B, A);
		}else if(Type === "Tile"){
			var X = Info[0] || 1;
			var Y = Info[1] || 1;
			
			Content.Tile(X, Y);
		}else{
			Logger.ConsoleWarn("Тип модификатора [" + Type + "], не найден!");
		}
		
		return Content;
	}catch(e){
		throw new Error("Произошла ошибка при применении модификатора [" + Type + "]!", e);
	}
}

/* Применение модификаторов */
async function ApplyActions(Content, Actions){
	try{
		if(!Actions || !Actions.length){ return Content; }
		
		Content = Content.Clone();
		
		for(var Action of Actions){ Content = await ApplyAction(Content, Action[0], Action.slice(1)); }
		
		return Content;
	}catch(e){
		throw new Error("Произошла ошибка при применении модификаторов!", e);
	}
}

/* Файл с выводом информации */
var BuildFile;

/* Содержимое сгенерированного файла [Если указать только 1 аргумент, будет считаться как в памяти] */
async function GenerateFile(Path, Info = null, IgnoreTags = false){
	var MemoryFile = Path && !Info;
	if(MemoryFile){ Info = Path; Path = null; }

	try{		
		/* Как генерировать файл */
		var GenerateType = Info[0];
		/* Дополнительная информация и теги */
		var Tag = null;
		
		if(Array.isArray(GenerateType)){
			Tag = GenerateType[1];
			GenerateType = GenerateType[0];
		}
		
		if(!IgnoreTags && Tag && Tag[0] === "BuildFile"){
			BuildFile = [Path, Info];
			return null;
		}
		
		if(MemoryFile){
			Logger.Console("Генерация файла в памяти...");
		}else{
			Logger.Console("Генерация [" + Path + "]...");
		}
		
		var Actions = null;
		
		var Result = "Не найден тип генерации [" + GenerateType + "]!";
		
		if(GenerateType === "File"){
			var FilePath = Info[1];
			Actions = Info[2] || null;
			Result = await GetFile(FilePath);
		}else if(GenerateType === "Texture"){
			var FilePath = Info[1];
			Actions = Info[2] || null;
			Result = await GetTexture(FilePath);
		}else if(GenerateType === "Create"){
			if(typeof Info[1] === "number" && typeof Info[2] === "number"){
				var W = Info[1];
				var H = Info[2];
				var Color = Info[3] || "transparent";
				Actions = Info[4] || null;
				
				Result = new Texture(W, H, Color);
			}else if(Array.isArray(Info[1])){
				var File = await GenerateFile(Info[1]);
				var Content = await FileContent(File);
				
				Result = UpdateString(Content);
			}else{
				var Content = Info[1];
				Actions = Info[2] || null;
				Result = UpdateString(Content);
			}
		}else if(GenerateType === "Atlas"){
			var AtlasInfo = Info[1];
			Actions = Info[2] || null;
			Result = await GenerateAtlas(AtlasInfo);
		}else if(GenerateType === "Painting"){
			var W = Info[1];
			var H = Info[2];
			Actions = Info[3] || null;
			Result = await GeneratePainting(W, H);
		}else{
			Logger.ConsoleWarn("Тип файла [" + GenerateType + "], не найден!");
		}
		
		Result = await ApplyActions(Result, Actions);
		return Result;
	}catch(e){
		Logger.ConsoleError("Произошла ошибка при генерации файла " + (MemoryFile ? "в памяти" : "[" + Path + "]") + "!", e);
		return "Произошла ошибка при генерации этого файла...";
	}
}

/* ======================================================== */

/* Генерация атласа */
async function GenerateAtlas(Info){
	try{
		var Empty = Info["Empty"] ? await GenerateFile(Info["Empty"]) : false;
		var Size  = Info["Size" ] || [1 , 1 ];
		var Scale = Info["Scale"] || [16, 16];
		var TrueScale = Scale === true;
		if(TrueScale){ Scale = [1, 1]; }
		var W     = Size[0];
		var H     = Size[1];
		
		if(W <= 0 || H <= 0){ throw new Error("Размер атласа <= 0!\nW: " + W + " | H: " + H); }
		
		var Atlas = new Texture(W * Scale[0], H * Scale[1]);
		
		if(!TrueScale){
			W += 1; H += 1;
		}
		
		var OneZero = TrueScale ? 0 : 1;
		
		for(var X = OneZero; X < W; X++){
			for(var Y = OneZero; Y < H; Y++){
				try{
					var Tile = null;
					var X_ = Info[X];
					if(X_){
						var Y_ = X_[Y];
						if(Y_ != undefined){
							if(Y_ === false){
								Tile = false;
							}else{
								Tile = await GenerateFile(Y_);
							}
						}
					}
					
					if(Tile != false){
						Atlas.Set(Tile ? Tile : Empty, (X - OneZero) * Scale[0], (Y - OneZero) * Scale[1]);
					}
				}catch(e){
					Logger.Error("Произошла ошибка генерации тайтла [" + X + ":" + Y + "] у атласа!");
				}
			}
		}
		
		return Atlas;
	}catch(e){
		throw new Error("Произошла ошибка при генерации атласа!", e);
	}
}

/* Все картины */
var AllPaintings;

/* Генерация картины */
async function GeneratePainting(W, H){
	try{
		if(W === true && !H){ return await GetTexture(ChangelogTexture); }
	
		var PaintingSize = W + "x" + H;
	
		var FrameTexture = "R/T/ART/Frame_" + PaintingSize + ".png";
	
		var PaintingFamily = __AllPaintings[PaintingSize];
		if(!PaintingFamily || PaintingFamily.length === 0){
			Logger.ConsoleWarn("Закончились картины типа [" + PaintingSize + "]!");
			return await GenerateFile(["Texture", "R/T/ART/Empty.png", [["Put", ["Texture", FrameTexture]]]]);
		}
	
		var Painting = PaintingFamily.splice(Math.floor(Math.random() * PaintingFamily.length), 1)[0];
		return await GenerateFile(["Texture", Painting, [["Put", ["Texture", FrameTexture]]]]);
	}catch(e){
		throw new Error("Произошла ошибка при генерации картины " + W + "x" + H + "!", e);
	}
}
var __AllPaintings;

/* ======================================================== */

class Texture{
	constructor(W, H, Content = null){
		try{
			if(W <= 0 || H <= 0){ throw new Error("Размеры текстуры <= 0!"); }
			
			this.W = W;
			this.H = H;
			
			this.C = document.createElement("Canvas");
			this.C.width = W; this.C.height = H;
			this.CTX = this.C.getContext("2d");
			
			this.Content = new Uint8ClampedArray(W * H * 4);
			
			this.Fill(Content);
		}catch(e){
			throw new Error("Произошла ошибка при создании текстуры! new Texture(" + W + ", " + H + ", ...);", e);
		}
	}
	
	/* Полностью закрасить текстуру */
	Fill(Content, Blend = "source-over", IgnoreAlpha = false){
		try{
			if(!Content){ return; }
		
			var Data = Content;
			if(Content instanceof Texture){ Data = Content.Content; }else if(!(Data instanceof Uint8ClampedArray)){ Data = CalculateColor(Data); }
			
			if(Data.length === 4){
				for(var i = 0; i < this.Content.length; i += 4){
					if(Blend === "multiply"){
						this.Content[i + 0] = Math.floor(this.Content[i + 0] * Data[0] / 255);
						this.Content[i + 1] = Math.floor(this.Content[i + 1] * Data[1] / 255);
						this.Content[i + 2] = Math.floor(this.Content[i + 2] * Data[2] / 255);
						if(IgnoreAlpha){ continue; }
						this.Content[i + 3] = Math.floor(this.Content[i + 3] * Data[3] / 255);
					}else{
						this.Content[i + 0] = Data[0];
						this.Content[i + 1] = Data[1];
						this.Content[i + 2] = Data[2];
						if(IgnoreAlpha){ continue; }
						this.Content[i + 3] = Data[3];
					}
				}
			}else{
				if(Blend === "multiply"){
					for(var i = 0; i < this.Content.length; i += 4){
						this.Content[i + 0] = Math.floor(this.Content[i + 0] * Data[i + 0] / 255);
						this.Content[i + 1] = Math.floor(this.Content[i + 1] * Data[i + 1] / 255);
						this.Content[i + 2] = Math.floor(this.Content[i + 2] * Data[i + 2] / 255);
						if(IgnoreAlpha){ continue; }
						this.Content[i + 3] = Math.floor(this.Content[i + 3] * Data[i + 3] / 255);
					}
				} else {
					this.Content.set(Data);
				}
			}
			
			this.__UpdateCanvas();
			
			return this;
		}catch(e){
			throw new Error("Произошла ошибка при заливке текстуры [" + this + "]!", e);
		}
	}
	
	/* Добавляет текстуру на текстуру */
	Put(Content, X = 0, Y = 0, Blend = "alpha"){
		if(Content === false){ return; }
	
		const PrevBlend = this.CTX.globalCompositeOperation;
		if(Blend !== "alpha"){ this.CTX.globalCompositeOperation = Blend; }
	
		try{
			if(X < 0 || Y < 0){ throw new Error("Позиция < 0!"); }
			if(X > this.W || Y > this.H){ throw new Error("Позиция > размера текстуры!"); }
		
			if(Blend === "alpha"){
				var Data;
				if(Content instanceof Texture){
					Data = Content.Content;
				}else if(Content instanceof Uint8ClampedArray){
					Data = Content;
				}else{
					throw new Error("Нужен Texture!");
				}
				
				var W = Content.W || this.W;
				var H = Content.H || this.H;
				
				const SY = Math.max(0,        - Y);
				const EY = Math.min(H, this.H - Y);
				const SX = Math.max(0,        - X);
				const EX = Math.min(W, this.W - X);

				for(let Y_ = SY; Y_ < EY; Y_++){
					for(let X_ = SX; X_ < EX; X_++){
						const CI = ((Y_ + Y) * this.W + (X_ + X)) * 4;
						const DI = (Y_ * W + X_) * 4;

						const BaseR = this.Content[CI + 0];
						const BaseG = this.Content[CI + 1];
						const BaseB = this.Content[CI + 2];
						const BaseA = this.Content[CI + 3] / 255;

						const OverR = Data[DI + 0];
						const OverG = Data[DI + 1];
						const OverB = Data[DI + 2];
						const OverA = Data[DI + 3] / 255;

						const OutA = OverA + BaseA * (1 - OverA);
						if(OutA === 0){ continue; }

						this.Content[CI + 0] = Math.round((OverR * OverA + BaseR * BaseA * (1 - OverA)) / OutA);
						this.Content[CI + 1] = Math.round((OverG * OverA + BaseG * BaseA * (1 - OverA)) / OutA);
						this.Content[CI + 2] = Math.round((OverB * OverA + BaseB * BaseA * (1 - OverA)) / OutA);
						this.Content[CI + 3] = Math.round(OutA * 255);
					}
				}
				
				this.__UpdateCanvas();
			}else{
				if(Content instanceof Texture){
					this.CTX.drawImage(Content.C, X, Y);
				}else if(Content instanceof Uint8ClampedArray){
					this.CTX.putImageData(new ImageData(Content, this.W, this.H), X, Y);
				}else{
					throw new Error("Нужен Texture!");
				}
				
				this.__UpdateContent();
			}
			
			return this;
		}catch(e){
			throw new Error("Произошла ошибка при добавлении текстуры на текстуру [" + this + "]! Put(..., " + X + ", " + Y + ");", e);
		}finally{
			if(Blend !== "alpha"){ this.CTX.globalCompositeOperation = PrevBlend; }
		}
	}
	
	/* Заменяет текстуру */
	Set(Content, X = 0, Y = 0){ return this.Put(Content, X, Y, "source-over"); }
	
	/* Устанавливает цвет заднего фона */
	Background(Color = "white"){
		try{
			var Current = new Uint8ClampedArray(this.Content);
			this.Fill(Color        );
			this.Put (Current, 0, 0);
			
			return this;
		}catch(e){
			throw new Error("Произошла ошибка при установке цвета заднего фона текстуре [" + this + "]! Background(" + Color + ");", e);
		}
	}
	
	/* Обрезать текстуру */
	Crop(X, Y, W, H){
		try{
			if(X < 0 || Y < 0 || X + W > this.W || Y + H > this.H){ throw new Error("Параметры выходят за пределы текстуры!"); }
			
			const NewContent = new Uint8ClampedArray(W * H * 4);

			for(var Y_ = 0; Y_ < H; Y_++){
				for(var X_ = 0; X_ < W; X_++){
					const CI = ((Y_ + Y) * this.W + (X_ + X)) * 4;
					const DI = (Y_ * W + X_) * 4;

					NewContent[DI + 0] = this.Content[CI + 0];
					NewContent[DI + 1] = this.Content[CI + 1];
					NewContent[DI + 2] = this.Content[CI + 2];
					NewContent[DI + 3] = this.Content[CI + 3];
				}
			}

			this.Content = NewContent;
			this.W = W; this.H = H;
			
			this.C.width = W; this.C.height = H;
			this.CTX.putImageData(new ImageData(this.Content, W, H), 0, 0);

			return this;
		}catch(e){
			throw new Error("Произошла ошибка при обрезке текстуры [" + this + "]! Crop(" + X + ", " + Y + ", " + W + ", " + H + ");", e);
		}
	}
	
	/* Получает кадр из анимированной текстуры */
	Frame(Index = 0){
		try{
			const TotalFrames = Math.floor(this.H / this.W);
			
			if(Index < 0 || Index >= TotalFrames){ throw new Error("Индекс кадра выходит за пределы анимации!"); }
			
			return this.Crop(Index * this.W, 0, this.W, this.W);
		}catch(e){
			throw new Error("Произошла ошибка при получении кадра из анимации у текстуры [" + this + "]! Frame(" + Index + ");", e);
		}
	}
	
	/* Изменяет размер текстуры, так же содержимое */
	Resize(W, H, Smooth = true){
		try{
			if(W <= 0 || H <= 0){ throw new Error("Новый размер <= 0!"); }
			
			const OW = this.W;
			const OH = this.H;
			const NewContent = new Uint8ClampedArray(W * H * 4);

			for(var Y = 0; Y < H; Y++){
				for(var X = 0; X < W; X++){
					const NI = (Y * W + X) * 4;

					if(Smooth){
						const GX = (X + 0.5) * OW / W - 0.5;
						const GY = (Y + 0.5) * OH / H - 0.5;
						const GXI = Math.floor(GX);
						const GYI = Math.floor(GY);
						const DX = GX - GXI;
						const DY = GY - GYI;

						for(var P = 0; P < 4; P++){
							const P00 = this.Content[((Math.min(GYI    , OH - 1) * OW + Math.min(GXI    , OW - 1)) * 4) + P];
							const P10 = this.Content[((Math.min(GYI    , OH - 1) * OW + Math.min(GXI + 1, OW - 1)) * 4) + P];
							const P01 = this.Content[((Math.min(GYI + 1, OH - 1) * OW + Math.min(GXI    , OW - 1)) * 4) + P];
							const P11 = this.Content[((Math.min(GYI + 1, OH - 1) * OW + Math.min(GXI + 1, OW - 1)) * 4) + P];

							const P0 = P00 * (1 - DX) + P10 * DX;
							const P1 = P01 * (1 - DX) + P11 * DX;
							NewContent[NI + P] = Math.round(P0 * (1 - DY) + P1 * DY);
						}
					} else {
						const OX = Math.floor(X * OW / W);
						const OY = Math.floor(Y * OH / H);
						const OI = (OY * OW + OX) * 4;
						NewContent[NI + 0] = this.Content[OI + 0];
						NewContent[NI + 1] = this.Content[OI + 1];
						NewContent[NI + 2] = this.Content[OI + 2];
						NewContent[NI + 3] = this.Content[OI + 3];
					}
				}
			}

			this.W = W; this.H = H;
			this.Content = NewContent;

			this.C.width = W; this.C.height = H;
			this.CTX.putImageData(new ImageData(this.Content, W, H), 0, 0);

			return this;
		}catch(e){
			throw new Error("Произошла ошибка при изменении размера у текстуры [" + this + "] и содержимого! Resize(" + W + ", " + H + ", " + Smooth + ");", e);
		}
	}
	
	/* Изменяет размер текстуры, не трогая содержимое */
	NewSize(W = null, H = null){
		try{
			if(W === null){ W = this.W; }
			if(H === null){ H = this.H; }
		
			if(W <= 0 || H <= 0){ throw new Error("Новый размер <= 0!"); }
			
			const OW = this.W; const OH = this.H;
			const OContent = this.Content ? new Uint8ClampedArray(this.Content) : null;

			this.W = W; this.H = H;

			this.Content = new Uint8ClampedArray(W * H * 4);

			this.C.width = W;  this.C.height = H;

			if(OContent){
				const CW = Math.min(OW, W);
				const CH = Math.min(OH, H);

				for(var Y = 0; Y < CH; Y++){
					for(var X = 0; X < CW; X++){
						const OI = (Y * OW + X) * 4;
						const NI = (Y *  W + X) * 4;
						this.Content[NI + 0] = OContent[OI + 0];
						this.Content[NI + 1] = OContent[OI + 1];
						this.Content[NI + 2] = OContent[OI + 2];
						this.Content[NI + 3] = OContent[OI + 3];
					}
				}
			}

			this.__UpdateCanvas();

			return this;
		}catch(e){
			throw new Error("Произошла ошибка при изменении размера у текстуры [" + this + "]! NewSize(" + W + ", " + H + ");", e);
		}
	}
	
	/* Двигает текстуру */
	Move(X = 0, Y = 0){
		try{
			if(X === 0 && Y === 0){ return this; } // нет смещения — ничего не делаем

			const NewContent = new Uint8ClampedArray(this.W * this.H * 4);

			// Рассчитываем области копирования
			const StartX = Math.max(0, X);
			const StartY = Math.max(0, Y);
			const EndX   = Math.min(this.W, this.W + X);
			const EndY   = Math.min(this.H, this.H + Y);

			const SrcStartX = Math.max(0, -X);
			const SrcStartY = Math.max(0, -Y);

			for(let NY = StartY, SY = SrcStartY; NY < EndY; NY++, SY++){
				for(let NX = StartX, SX = SrcStartX; NX < EndX; NX++, SX++){
					const OI = (SY * this.W + SX) * 4;
					const NI = (NY * this.W + NX) * 4;
					NewContent[NI + 0] = this.Content[OI + 0];
					NewContent[NI + 1] = this.Content[OI + 1];
					NewContent[NI + 2] = this.Content[OI + 2];
					NewContent[NI + 3] = this.Content[OI + 3];
				}
			}

			this.Content = NewContent;
			this.__UpdateCanvas();

			return this;
		}catch(e){
			throw new Error("Произошла ошибка при движении текстуры [" + this + "]! Move(" + X + ", " + Y + ");", e);
		}
	}
	
	/* Применяет градиент */
	Gradient(Gradient_){
		try{
			if(!(Gradient_ instanceof Texture)){ throw new Error("Градиент должен быть формата Texture!"); }
			if(Gradient_.W !== 256 || Gradient_.H !== 1){ throw new Error("Размер градиента должен быть 256x1!"); }
			
			for(var i = 0; i < this.Content.length; i += 4){
				const Gray = this.Content[i];
				
				const GI = Gray * 4;
				this.Content[i + 0] = Gradient_.Content[GI + 0];
				this.Content[i + 1] = Gradient_.Content[GI + 1];
				this.Content[i + 2] = Gradient_.Content[GI + 2];
				this.Content[i + 3] = Math.min(this.Content[i + 3], Gradient_.Content[GI + 3]);
			}
			
			this.__UpdateCanvas();
			return this;
		}catch(e){
			throw new Error("Произошла ошибка при применении градиента текстуре [" + this + "]! Gradient(" + Gradient_ + ");", e);
		}
	}
	
	/* Умножает цвет */
	Multiply(Color){
		try{
			return this.Fill(Color, "multiply", true);
		}catch(e){
			throw new Error("Произошла ошибка при умножении на цвет [" + Color + "] у текстуры [" + this + "]! Multiply(" + Color + ");", e);
		}
	}
	
	/* Устанавливает канал */
	Fixed(R = null, G = null, B = null, A = null){
		try{
			if(R && R > 255 || R < 0){ throw new Error("Красный цвет выходит за пределы 0 и 255!"); }
			if(G && G > 255 || G < 0){ throw new Error("Зелёный цвет выходит за пределы 0 и 255!"); }
			if(B && B > 255 || B < 0){ throw new Error("Синий цвет выходит за пределы 0 и 255!"  ); }
			if(A && A > 255 || A < 0){ throw new Error("Прозрачность выходит за пределы 0 и 255!"); }
		
			for (var i = 0; i < this.Content.length; i += 4) {
				if (R !== null){ this.Content[i + 0] = R; }
				if (G !== null){ this.Content[i + 1] = G; }
				if (B !== null){ this.Content[i + 2] = B; }
				if (A !== null){ this.Content[i + 3] = A; }
			}
			
			this.__UpdateCanvas();
			return this;
		}catch(e){
			throw new Error("Произошла ошибка при установке каналов текстуре [" + this + "]! Fixed(" + R + ", " + G + ", " + B + ", " + A + ");", e);
		}
	}
	
	/* Отзеркаливает */
	Flip(X = false, Y = false){
		try{
			if(!X && !Y){ return; }
			
			const Old = new Uint8ClampedArray(this.Content);
			const NewContent = new Uint8ClampedArray(this.W * this.H * 4);

			for(let y = 0; y < this.H; y++){
				for(let x = 0; x < this.W; x++){
					const srcX = X ? (this.W - 1 - x) : x;
					const srcY = Y ? (this.H - 1 - y) : y;

					const srcIndex = (srcY * this.W + srcX) * 4;
					const dstIndex = (y * this.W + x) * 4;

					NewContent[dstIndex + 0] = Old[srcIndex + 0];
					NewContent[dstIndex + 1] = Old[srcIndex + 1];
					NewContent[dstIndex + 2] = Old[srcIndex + 2];
					NewContent[dstIndex + 3] = Old[srcIndex + 3];
				}
			}

			this.Content = NewContent;
			this.__UpdateCanvas();

			return this;
		}catch(e){
			throw new Error("Произошла ошибка при отзеркаливании текстуры [" + this + "]! Flip(" + X + ", " + Y + ");", e);
		}
	}
	
	/* Обрезка каналов */
	Trim(R = null, G = null, B = null, A = null){
		try{
			const Rules = [R, G, B, A];
			
			for(var i = 0; i < this.Content.length; i += 4){
				for(var c = 0; c < 4; c++){
					const Rule = Rules[c];
					if(!Rule){ continue; }
					
					const Value = this.Content[i + c];
					
					const Left = Rule[0]; const Right = Rule[1];
					
					if(Left != null){
						this.Content[i + c] = (Value <= Left[0] ? Left[1] : Value);
						continue;
					}
					if(Right != null){
						this.Content[i + c] = (Value => Right[0] ? Right[1] : Value);
					}
				}
			}
			
			this.__UpdateCanvas();
			return this;
		}catch(e){
			throw new Error("Произошла ошибка при обрезке текстуры [" + this + "]! Trim(" + R + ", " + G + ", " + B + " ," + A + ");", e);
		}
	}
	
	/* Инвертирует канал */
	Invert(R = true, G = true, B = true, A = false){
		try{
			for(let i = 0; i < this.Content.length; i += 4){
				if(R){ this.Content[i + 0] = 255 - this.Content[i + 0]; }
				if(G){ this.Content[i + 1] = 255 - this.Content[i + 1]; }
				if(B){ this.Content[i + 2] = 255 - this.Content[i + 2]; }
				if(A){ this.Content[i + 3] = 255 - this.Content[i + 3]; }
			}

			this.__UpdateCanvas();
			return this;
		}catch(e){
			throw new Error("Произошла ошибка при инвертировании каналов у текстуры [" + this + "]! Invert(" + R + ", " + G + ", " + B + " ," + A + ");", e);
		}
	}
	
	/* Повторяет текстуру */
	Tile(X = 1, Y = 1){
		try{
			if(X <= 0 || Y <= 0){ throw new Error("Кол-во Tile <= 0!"); }
			
			const NewW = this.W * X;
			const NewH = this.H * Y;
			const NewContent = new Uint8ClampedArray(NewW * NewH * 4);

			for(let ty = 0; ty < Y; ty++){
				for(let tx = 0; tx < X; tx++){
					for(let y = 0; y < this.H; y++){
						for(let x = 0; x < this.W; x++){
							const SrcIndex = (y * this.W + x) * 4;
							const DestIndex = ((ty * this.H + y) * NewW + (tx * this.W + x)) * 4;

							NewContent[DestIndex + 0] = this.Content[SrcIndex + 0];
							NewContent[DestIndex + 1] = this.Content[SrcIndex + 1];
							NewContent[DestIndex + 2] = this.Content[SrcIndex + 2];
							NewContent[DestIndex + 3] = this.Content[SrcIndex + 3];
						}
					}
				}
			}

			this.W = NewW;
			this.H = NewH;
			this.Content = NewContent;

			this.C.width = NewW;
			this.C.height = NewH;
			this.__UpdateCanvas();

			return this;
		}catch(e){
			throw new Error("Произошла ошибка при повторении текстуры [" + this + "]! Tile(" + X + ", " + Y + ");", e);
		}
	}
	
	/* ======================================================== */
	
	/* Получает цвет из пикселя */
	GetColor(X, Y){
		try{
			if(X < 0 || Y < 0 || X >= this.W || Y >= this.H){ throw new Error("Пиксель выходит за пределы текстуры!"); }
			
			const i = (Y * this.W + X) * 4;
			
			return [
				this.Content[i + 0],
				this.Content[i + 1],
				this.Content[i + 2],
				this.Content[i + 3]
			];
		}catch(e){
			throw new Error("Произошла ошибка при получении цвета пикселя у текстуры [" + this + "]! GetColor(" + X + ", " + Y + ");", e);
		}
	}
	
	/* Клонирует текстуру */
	Clone(){
		return new Texture(this.W, this.H, this.Content);
	}
	
	async ToBlob(){
		return await new Promise(R => this.C.toBlob(R, "image/png"));
	}
	
	__UpdateCanvas(){
		this.CTX.putImageData(new ImageData(this.Content, this.W, this.H), 0, 0);
	}
	
	__UpdateContent(){
		this.Content.set(this.CTX.getImageData(0, 0, this.W, this.H).data);
	}
	
	toString(){
		return "Texture[" + this.W + "x" + this.H + "]";
	}
}

/* ======================================================== */

/* Получить файл */
async function GetFile(Path, ThatTexture = false){
	Path = Path.replace(/\\/g, "/").replace(/\/+/g, "/");
	
	if(__GetFileCache[Path]){ return __GetFileCache[Path]; }
	
	var File = PackFiles[Path];
	if(!File){ throw new Error("Файл [" + Path + "] не найден!"); }
	
	if(ThatTexture){
		const Extension = Path.split(".").pop().toLowerCase();
		
		if(Extension === "texture"){
			const TextureInfo = await FileContentJSON(File);
			
			File = await GenerateFile(Path, TextureInfo);
		}else{
			const PNGContent = await FileContentByte(File);
		
			const Blob_  = new Blob([PNGContent], { type: "image/png" });
			
			const { W, H, Content } = await new Promise((R, E) => {
				const Image_ = new Image();
				Image_.onload = () => {
					const C = document.createElement("canvas");
					C.width = Image_.width;
					C.height = Image_.height;
					const CTX = C.getContext("2d");
					CTX.drawImage(Image_, 0, 0);
					const ImageData = CTX.getImageData(0, 0, Image_.width, Image_.height);
					URL.revokeObjectURL(Image_.src);
					R({ W: Image_.width, H: Image_.height, Content: ImageData.data });
				};
				Image_.onerror = E;
				Image_.src = URL.createObjectURL(Blob_);
			});
			
			File = new Texture(W, H, new Uint8ClampedArray(Content));
		}
	}
	
	__GetFileCache[Path] = File;
	return File;
}
const __GetFileCache = {};

/* Получить текстуру */
async function GetTexture(Path){ return await GetFile(Path, true); }

/* Получить содержимое файла в виде JSON */
async function FileContentJSON(File){
	try{
		var Text = await FileContent(File);
		return JSONParse(Text);
	}catch(e){
		throw new Error("Произошла ошибка при чтении файла [" + File.name + "], в формате JSON!", e);
	}
}

const __FilesContentString = {};
const __FilesContentBytes  = {};

/* Получить строковое содержимое файла */
async function FileContent(File){
	if(__FilesContentString[File.name]){ return __FilesContentString[File.name]; }
	
	try{
		const Text = await File.async("text");
		__FilesContentString[File.name] = Text;
		return Text;
	}catch(e){
		throw new Error("Произошла ошибка при чтении файла [" + File.name + "]!", e);
	}
}

/* Получить байтовое содержимое файла */
async function FileContentByte(File){
	if(File instanceof Texture){ return File.Content; }
	if(__FilesContentBytes[File.name]){ return __FilesContentBytes[File.name]; }
	
	try{
		const Buf = await File.async("uint8array");
		const Bytes = new Uint8Array(Buf);
		__FilesContentBytes[File.name] = Bytes;
		return Bytes;
	}catch(e){
		throw new Error("Произошла ошибка при чтении файла [" + File.name + "], в формате Bytes!", e);
	}
}

/* ======================================================== */

/* Файлы пака (Все файлы) */
const PackFiles = {};
/* Папки пака (Файлы внутри папок) [Файлы без пути к папке] */
const PackFolders = {};

/* Информация об паке */
var PackInfo;

/* Автор пака */
var Author;

/* Лицензия пака */
var License;

/* Версия пака */
var PackVersion;

/* Название коммита */
var CommitName;

/* Доступные версии пака */
var PackVersions = {}

/* Выбранная версия */
var SelectedVersion = null;

/* Загрузка генератора */
async function LoadGenerator(File, FileName, Loaded = new Set()){
	try{
		if(Loaded.has(FileName)){ return null; }
		var FirstGenerator = Loaded.size === 0;
		Loaded.add(FileName);
		
		const Info = await FileContentJSON(File);
		
		function MergeObjects(Base, Overlay){
			const Result = { ...Base };

			for (const Key in Overlay) {
				if (!Overlay.hasOwnProperty(Key)) continue;

				const DataBase    = Base   [Key];
				const DataOverlay = Overlay[Key];
				
				if(DataOverlay === null){
					delete Result[Key];
					continue;
				}

				if (DataBase && typeof DataBase === "object" && DataOverlay && typeof DataOverlay === "object") {
					if (!Array.isArray(DataBase) && !Array.isArray(DataOverlay)) {
						Result[Key] = MergeObjects(DataBase, DataOverlay);
					} else {
						Result[Key] = DataOverlay;
					}
				} else {
					Result[Key] = DataOverlay;
				}
			}

			return Result;
		}
		
		function MergeFiles(Base, Overlay){
			const Result = { ...Base };
			
			for(const Key in Overlay){
				if (!Overlay.hasOwnProperty(Key)){ continue; }
			
				const BaseValue    = Base[Key];
				const OverlayValue = Overlay[Key];
			
				if (OverlayValue === null){
					delete Result[Key];
					continue;
				}
			
				if(Array.isArray(Base[Key]) && Array.isArray(Overlay[Key]) && Base[Key][0] === "Atlas" && Overlay[Key][0] === "Atlas"){
					const [_ , DataBase   ] = Base   [Key];
					const [__, DataOverlay] = Overlay[Key];
					
					Result[Key] = ["Atlas", MergeObjects(DataBase, DataOverlay)];
					continue;
				}
				
				Result[Key] = Overlay[Key];
			}
			
			return Result;
		}
		
		if(Info.Parent){
			const Parent = await GetFile("G/" + Info.Parent);
			var ParentInfo = await LoadGenerator(Parent, Info.Parent, Loaded);
			Info.Files = MergeFiles(ParentInfo.Files, Info.Files);
			Info.__Info = Info.__Info || {};
			Info.__Info.Parent = ParentInfo["Name"];
		}
		
		if(FirstGenerator && Array.isArray(Info.Add)){
			for(const Add of Info.Add){
				var AddInfo = await LoadGenerator(await GetFile("G/" + Add), Add, Loaded);
				if(AddInfo){
					Info.Files = MergeFiles(Info.Files, AddInfo.Files);
					Info.__Info = Info.__Info || {};
					Info.__Info.Added = Info.__Info.Added || [];
					Info.__Info.Added.push(AddInfo["Name"]);
				}
			}
			delete Info.Add;
		}
		
		return Info;
	}catch(e){
		throw new Error("Произошла ошибка при загрузке генератора [" + FileName + "]!", e);
	}
}

/* Получает разную информацию из пака */
async function LoadPackInformation(){
	try{
		for(const Path of Object.keys(PackFiles)){
			const LastSlash = Path.lastIndexOf("/");
			const Folder    = LastSlash === -1 ? ""   : Path.substring(0,  LastSlash);
			
			if(!PackFolders[Folder]){ PackFolders[Folder] = []; }
			PackFolders[Folder].push(PackFiles[Path]);
		}
		
		PackInfo    = await FileContentJSON(await GetFile("Info.json"));
		Author      = PackInfo["Author" ];
		License     = PackInfo["License"];
		PackVersion = PackInfo["Version"]; $("#PackVersion").text(PackVersion);
		
		try{
			const Response = await fetch("https://api.github.com/repos/Woowz11/BloodRaw-Minecraft/commits/main");
			if(!Response.ok){ throw new Error("Ошибка загрузки: " + Response.status); }
			
			const Commit = await Response.json();
			
			CommitName = Commit.commit.message.split("\n")[0];
		}catch(e){
			Logger.Error("Произошла ошибка при получении версии репозитория!", e);
			CommitName = "Не получилось узнать...";
		}
		
		var VersionHierarchy;
		
		for(const File of PackFolders["G"]){
			var GeneratorInfo = await FileContentJSON(File);
			
			if(File.name.includes("Hierarchy")){
				if(File.name.includes("Version")){ VersionHierarchy = GeneratorInfo; }
			}else{
				var Type = GeneratorInfo["Type"  ] || "Unknown"; GeneratorInfo["Type"  ] = Type  ;
				
				if(Type === "Version"){
					PackVersions[GeneratorInfo["Name"]] = [File, GeneratorInfo["Name"], GeneratorInfo];
				}
			}
		}
		
		var AllVersions = Object.keys(PackVersions);
		AllVersions = AllVersions.sort((A, B) => {
			const iA = VersionHierarchy.indexOf(A);
			const iB = VersionHierarchy.indexOf(B);
			
			if(iA === -1){ throw new Error("Не найдена версия [" + A + "] в иерархии!"); }
			if(iB === -1){ throw new Error("Не найдена версия [" + B + "] в иерархии!"); }

			return iA - iB;
		});
		
		const SortedPackVersions = {};
		for(const Version of AllVersions){
			SortedPackVersions[Version] = PackVersions[Version];
		}
		PackVersions = SortedPackVersions;
		
		var ChangelogTexture_ = await GetTexture(ChangelogTexture);
		document.getElementById("ChangelogImage").src = ChangelogTexture_.C.toDataURL("image/png");
	}catch(e){
		throw new Error("Произошла ошибка при загрузке информации об паке!", e);
	}
}

/* Загружает картины */
function LoadPaintings(){
	try{
		AllPaintings = {};
		for(var File of PackFolders["R/T/ART"]){
			var Path = File.name.split("/").pop();
			var Match = Path.match(/^(\d+x\d+)_(\d+)\.png$/i);
			if (!Match){ continue; }
			
			var PaintingSize = Match[1];

			if(!AllPaintings[PaintingSize]){ AllPaintings[PaintingSize] = []; }
			
			AllPaintings[PaintingSize].push("R/T/ART/" + Path);
		}
	}catch(e){
		throw new Error("Произошла ошибка при загрузке картин!", e);
	}
}

/* Загружает цвета */
async function LoadColors(){
	try{
		var GrassColormap  = await GetTexture("R/T/O/Colormap_Grass.png" );
		var LeavesColormap = await GetTexture("R/T/O/Colormap_Leaves.png");
		
		var GrassColor  = GrassColormap .GetColor(127, 127);
		var LeavesColor = LeavesColormap.GetColor(127, 127);
		
		__Colors["Grass" ] = `rgb(${GrassColor[0]},${GrassColor[1]},${GrassColor[2]})`;
		__Colors["Leaves"] = `rgb(${LeavesColor[0]},${LeavesColor[1]},${LeavesColor[2]})`;
	}catch(e){
		throw new Error("Произошла ошибка при загрузке цветов!", e);
	}
}

/* Вызывается после пре-загрузки */
async function PreLoadAfter(){
	if(!StartPreLoaded){ return; }
	try{
		await LoadPackInformation();
	
		const SelectVersion = $("#SelectVersion");
		
		SelectVersion.html(
			Object.keys(PackVersions).map(V => `<option value="${V}">${V}</option>`).join("")
		);

		function StyleSelection(D){
			if (!D.id){ return D.text; }
			const Dev = PackVersions[D.id][2].Dev;
			return $("<span>").text(D.text).css("color",
				Dev === false ? "white" : (Dev === "Error" ? "red" : (Dev === true ? "yellow" : (Dev ? "black" : "yellow")))
			);
		}

		SelectVersion.select2({
			placeholder: "Выберите версию",
			allowClear: true,
			templateResult   : StyleSelection,
			templateSelection: StyleSelection
		});
		
		SelectedVersion = SelectVersion.val();
		
		SelectVersion.on('change', function(){ SelectedVersion = SelectVersion.val(); });
		
		await LoadColors();
		
		LoadPaintings();
		
		PreLoaded = true;
	}catch(e){
		throw new Error("Произошла ошибка после пред-загрузки!", e);
	}
}

/* Начата пред-загрузка пака? */
var StartPreLoaded = false;
/* Пак пред-загружен? */
var PreLoaded = false;
/* Пре-загрузка пака (Только один раз!) */
async function PreLoad(Buf){
	if(StartPreLoaded || PreLoaded){ return; } StartPreLoaded = true;
	try{
		const ZIP = await JSZip.loadAsync(Buf);

		for (const Name of Object.keys(ZIP.files)) {
			const File = ZIP.files[Name];
			if(File.dir){ continue; }

			File.name = File.name.replace(/\\/g, "/").replace(/\/+/g, "/");
			PackFiles[Name.replace(/\\/g, "/").replace(/\/+/g, "/")] = File;
		}
		
		await PreLoadAfter();
	} catch(e){
		throw new Error("Произошла ошибка при пред-загрузке пака!", e);
	}
}

/* Вызывается при запуске сайта */
function Awake(){
	const PreLoadPack = $("#PreLoadPack");
	if (IsLocal){
		PreLoadPack.on("change", async (EV) => {
			try{
				const File = EV.target.files[0];
				if(!File){ return; }
				const Buf = await File.arrayBuffer();
				await PreLoad(Buf);
			}catch(e){
				Logger.Fatal("Произошла ошибка при получении пака с компьютера!", e);
			}
		});
		
		PreLoadPack.css("display", "unset");
	}else{
		(async () => {
			try{
				const response = await fetch(PackFile);
				if (!response.ok){ throw new __Error("Ошибка загрузки: " + response.status); }
				const Buf = await response.arrayBuffer();
				await PreLoad(Buf);
			}catch(e){
				Logger.Fatal("Произошла ошибка при получении пака с raw.githubusercontent.com!", e);
			}
		})();
	}
}
Awake();

/* Вызывается когда сайт загружен */
function SiteLoaded(){
	try{
	
	}catch(e){
		Logger.Fatal("Произошла ошибка при загрузке сайта!", e);
	}
}

$(document).ready(function(){ SiteLoaded(); });

</script>